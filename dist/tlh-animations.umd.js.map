{"version":3,"file":"tlh-animations.umd.js","sources":["../src/AnimationConstructor.js","../src/Helpers.js","../src/TimeLine.js","../src/ConfigVars.js","../animations.js"],"sourcesContent":["class AnimationConstructor {\r\n    constructor(container, props = {}) {\r\n        this.elements = { // to store DOM elements\r\n            container: container\r\n        };\r\n\r\n        this.customAnimations = props.customAnimations || {} // to define custom animations in child class\r\n\r\n        this.scrollCords = { // to define where the animation starts and ends in relation to the container and viewport\r\n            startAt: 0,\r\n            endAt: 0\r\n        }\r\n\r\n        this._cachedVWValue = window.innerWidth; // to manage resize events\r\n\r\n        this.progress = 0; // from 0 to 1\r\n        this.previousProgress = 0; // to manage update event\r\n        this.progressEnded = false; // to manage complete event\r\n        this.interfaceReady = false; // to wait until the first scroll event\r\n        this.hasStarted = false; // to manage start event\r\n\r\n        this._lastScrollTime = 0; // to manage scroll events\r\n\r\n        this.timeline = {} // to be defined in child class\r\n\r\n        this.options = {\r\n            start: 0, // 0 means when the top of the container hits the bottom of the viewport\r\n            end: 0, // 0 means when the bottom of the container hits the bottom of the viewport\r\n            markers: false, // show markers at start and end positions\r\n            pin: false, // pin the container during the animation\r\n            detectionMode: {\r\n                start: 'top', // top, center, bottom\r\n                end: 'bottom' // top, center, bottom\r\n            }, \r\n            scrollDistance: 0, // this value will be calculated automatically if set to 0\r\n            fullscreen: true, // if true, the animation will take the full height of the viewport * scrollDistance scaled\r\n            ...this.getDataOptions(), // get options from data attributes\r\n            ...props.options // override with props\r\n        }\r\n\r\n        this._eventDetailPool = {\r\n            container,\r\n            progress: 0,\r\n            containerRect: null,\r\n            scrollTop: 0,\r\n            progressReverse: 0\r\n        }\r\n    }\r\n}\r\n\r\nexport default AnimationConstructor;","export default class Helpers {\r\n    easing = {\r\n        linear: (t) => t,\r\n        easeIn: (t) => t * t,\r\n        easeOut: (t) => t * (2 - t),\r\n        easeInOut: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,\r\n        bounce: (t) => {\r\n            if (t < 1/2.75) {\r\n                return 7.5625 * t * t;\r\n            } else if (t < 2/2.75) {\r\n                return 7.5625 * (t -= 1.5/2.75) * t + 0.75;\r\n            } else if (t < 2.5/2.75) {\r\n                return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;\r\n            } else {\r\n                return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;\r\n            }\r\n        }\r\n    }\r\n\r\n    getElementPosition(element) {\r\n        if (typeof element === 'string') {\r\n            element = document.querySelector(element);\r\n        }\r\n        const rect = element.getBoundingClientRect();\r\n        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\r\n        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;\r\n        return { top: rect.top + scrollTop, left: rect.left + scrollLeft };\r\n    }\r\n\r\n    scrollTo (position, duration = 500, easing = 'linear') {\r\n        const start = window.scrollY || window.pageYOffset;\r\n        const getPosition = typeof position === 'number' ? position : this.getElementPosition(position).top;\r\n        const change = getPosition - start;\r\n        let startTime = null;\r\n\r\n        if (duration <= 0) {\r\n            window.scrollTo(0, getPosition);\r\n            return;\r\n        }\r\n\r\n        const animateScroll = (currentTime) => {\r\n            if (startTime === null) startTime = currentTime;\r\n            const timeElapsed = currentTime - startTime;\r\n            const progress = Math.min(timeElapsed / duration, 1);\r\n            \r\n            const val = this.easing[easing](progress) * change + start;\r\n            window.scrollTo(0, val);\r\n            \r\n            if (progress < 1) {\r\n                requestAnimationFrame(animateScroll);\r\n            }\r\n        };\r\n        \r\n        requestAnimationFrame(animateScroll);\r\n    }\r\n    \r\n    // Selector helper\r\n    selector = (target) => {\r\n        if (typeof target === 'string') {\r\n            return document.querySelectorAll(target);\r\n        }\r\n        return [target];\r\n    }\r\n};","class Animation {\r\n    constructor(animation, props) {\r\n        this.name = animation\r\n        this.props = props\r\n\r\n        this.container = props.container || null\r\n\r\n        this.start = props.start ? props.start : 0\r\n        this.end = props.end ? props.end : 100\r\n        this.duration = props.duration ? props.duration : 1\r\n        this.normalizedProgress = 0\r\n        this.hasStarted = false\r\n        this.progressEnded = false\r\n        this.progress = 0\r\n\r\n        if(!this.container) {\r\n            console.error('Container is required for animation:', animation);\r\n            return;\r\n        }\r\n\r\n        this.container.addEventListener(this.props.events.onUpdate, (e) => {\r\n            this.updateTimeline(e.detail.progress);\r\n        });\r\n\r\n        return this\r\n    }\r\n\r\n    onUpdate() {\r\n        if(this.progress === 0){\r\n            this.hasStarted = false;\r\n        }\r\n\r\n        this.progressEnded = this.progress === 1 ? 1 : (this.progress === 0 ? 0 : false);\r\n        if(this.props.onUpdate) this.props.onUpdate.bind(this)();\r\n    }\r\n\r\n    onStart (){\r\n        this.hasStarted = true;\r\n        if(this.props.onStart) this.props.onStart.bind(this)();\r\n    }\r\n\r\n    onComplete(){\r\n        if(this.props.onComplete) this.props.onComplete.bind(this)();\r\n    }\r\n\r\n    updateTimeline(progress) {\r\n        const { start, end, duration } = this;\r\n\r\n        // Cache de valores calculados\r\n        if (!this._cachedUnits) {\r\n            this._cachedUnits = {\r\n                startUnit: start * 0.01,\r\n                endUnit: end * 0.01\r\n            };\r\n        }\r\n        \r\n        const { startUnit, endUnit } = this._cachedUnits;\r\n        const baseProgress = this.props.normalizedProgress(startUnit, endUnit, progress);\r\n\r\n        let adjustedProgress;\r\n        if (duration !== 1) {\r\n        adjustedProgress = Math.pow(baseProgress, duration);\r\n        } else {\r\n        adjustedProgress = baseProgress;\r\n        }\r\n\r\n        adjustedProgress = Math.max(0, Math.min(1, adjustedProgress));\r\n\r\n        this.progress = baseProgress;\r\n        this.normalizedProgress = adjustedProgress;\r\n\r\n        if (this.progress > 0 && !this.hasStarted) {\r\n            this.onStart();\r\n        }\r\n\r\n        this.onUpdate();\r\n\r\n        if (progress === 1) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n}\r\n\r\nexport default class Timeline {\r\n    constructor(parent) {\r\n        this.parent = parent; // Referencia a la instancia padre\r\n        this.elements = parent.elements;\r\n        this.customEvents = parent.customEvents;\r\n        this.normalizedProgress = parent.normalizedProgress;\r\n    }\r\n\r\n    add(name, props) {\r\n        if(!name) {\r\n            console.error('Animation name is required');\r\n            return;\r\n        }\r\n        \r\n        if(!props) {\r\n            console.error('Animation props are required');\r\n            return;\r\n        }\r\n\r\n        return new Animation(name, {\r\n            ...props, \r\n            normalizedProgress: this.normalizedProgress,\r\n            container: this.elements.container, \r\n            events : this.customEvents\r\n        });\r\n    }\r\n}","const EVENTS = {\r\n    onUpdate: 'tlh-animate-update',\r\n    onStart: 'tlh-animate-start',\r\n    onComplete: 'tlh-animate-complete',\r\n    globalScroll: 'tlh-global-scroll',\r\n    globalResize: 'tlh-global-resize'\r\n}\r\n\r\nconst ELEMENTS_CLASS = {\r\n    marker: 'tlh-scroll-marker',\r\n    markerStart: 'tlh-scroll-marker-start',\r\n    markerEnd: 'tlh-scroll-marker-end',\r\n    pinSpacer: 'tlh-pin-section',\r\n    pinInner: 'tlh-pin-inner'\r\n}\r\n\r\nexport { EVENTS, ELEMENTS_CLASS };","import AnimationConstructor from \"./src/AnimationConstructor.js\";\r\nimport Helpers from \"./src/Helpers.js\";\r\nimport TimeLine from \"./src/TimeLine.js\";\r\nimport { EVENTS, ELEMENTS_CLASS } from \"./src/ConfigVars.js\";\r\n\r\nclass TLHAnimation extends AnimationConstructor {\r\n    constructor(container, props = {}) {\r\n      super(container, props);\r\n      this.props = props;\r\n\r\n      this.customEvents = {\r\n          onUpdate: EVENTS.onUpdate,\r\n          onStart: EVENTS.onStart,\r\n          onComplete: EVENTS.onComplete\r\n      };\r\n\r\n      this.timeline = new TimeLine(this);\r\n\r\n      this.init();\r\n    }\r\n\r\n    getDataOptions () {\r\n      const dataOptions = this.elements.container.dataset;\r\n      return dataOptions;\r\n    }\r\n\r\n    init() {\r\n      this.setElements('container', this.elements.container);\r\n      if(this.props.onMounted) this.props.onMounted.call(this);\r\n      this.setScrollCords();\r\n      this.createInterface();\r\n      this.setEvents();\r\n    }\r\n\r\n    setScrollCords() {\r\n      const { end, start } = this.options;\r\n      const vh = window.innerHeight;\r\n\r\n      const newStart = vh * (start * 0.01);\r\n      const newEnd = vh * (end * 0.01);\r\n\r\n      this.scrollCords.startAt = newStart;\r\n      this.scrollCords.endAt = newEnd;\r\n    }\r\n    \r\n    addToTimeline(props) {\r\n      if(!props.name) {\r\n        console.warn('You must provide a name for the timeline animation.');\r\n        return;\r\n      }\r\n\r\n      if(this.timeline[props.name]) {\r\n        console.warn(`Timeline animation with name \"${props.name}\" already exists.`);\r\n        return;\r\n      }\r\n  \r\n      this.timeline.add(props.name, props);\r\n\r\n      this._cachedAnimationKeys = null;\r\n    }\r\n\r\n    setElements(name, element) {\r\n      this.elements[name] = element;\r\n    }\r\n\r\n    addMarkers() {\r\n      if(!this.options.markers) return;\r\n      const { top, bottom } = this.getElementCords();\r\n      const { endAt, startAt } = this.scrollCords;\r\n      const { startMarker: startMarkerElement, endMarker: endMarkerElement } = this.elements;\r\n      const startMarker = startMarkerElement ?? document.createElement('div');\r\n      const endMarker = endMarkerElement ?? document.createElement('div');\r\n      startMarker.classList.add(ELEMENTS_CLASS.marker, ELEMENTS_CLASS.markerStart);\r\n      endMarker.classList.add(ELEMENTS_CLASS.marker, ELEMENTS_CLASS.markerEnd);\r\n      const { end, start } = this.options.detectionMode;\r\n\r\n      const markerStyle = (top, color) => `\r\n        position: absolute;\r\n        left: 0;\r\n        right: 0;\r\n        top: ${top}px;\r\n        width: 100%;\r\n        height: 2px;\r\n        z-index: 9999;\r\n        background: ${color};\r\n      `;\r\n\r\n      startMarker.style.cssText = markerStyle(top - startAt, 'green');\r\n      endMarker.style.cssText = markerStyle(bottom + endAt, 'red');\r\n\r\n      startMarker.textContent = `Start - once this touch the ${start} of the viewport`;\r\n      endMarker.textContent = `End - once this touch the ${end} of the viewport`;\r\n      \r\n      if(!startMarkerElement && !endMarkerElement) {\r\n        document.body.append(startMarker);\r\n        document.body.append(endMarker);\r\n        this.setElements('startMarker', startMarker);\r\n        this.setElements('endMarker', endMarker);\r\n      }\r\n    }\r\n\r\n    createPinInterface() {\r\n      const pinSection = document.createElement('div');\r\n      pinSection.classList.add(ELEMENTS_CLASS.pinSpacer);\r\n      pinSection.style.cssText = `\r\n        position: sticky;\r\n        top: 0;\r\n        height: 100vh;\r\n        width: 100%;\r\n        pointer-events: none;\r\n      `;\r\n\r\n      const children = Array.from(this.elements.container.childNodes);\r\n      children.forEach(child => {\r\n        pinSection.appendChild(child);\r\n      });\r\n\r\n      this.elements.container.appendChild(pinSection);\r\n    }\r\n\r\n    createInterface() {\r\n      const { container } = this.elements;\r\n      const { scrollDistance, fullscreen } = this.options;\r\n      const { endAt } = this.scrollCords;\r\n      const scaleDistance = scrollDistance * 0.01;\r\n      const windowHeight = window.innerHeight;\r\n\r\n      if(!scrollDistance && scrollDistance != 0) {\r\n        console.warn('scrollDistance must be defined on element or animation options');\r\n      }\r\n\r\n      const contentHeight = (windowHeight * scaleDistance);\r\n      \r\n      this.options.scrollTop = (contentHeight + endAt);\r\n      if(scrollDistance > 0 && fullscreen) {\r\n        const newHeight = windowHeight + contentHeight;\r\n        container.style.height = `${newHeight}px`;\r\n      }\r\n\r\n      this.interfaceReady = true\r\n\r\n      this.addMarkers()\r\n      if(this.options.pin) this.createPinInterface()\r\n    }\r\n\r\n    resize(force = false) {\r\n      if(this.resizeTimeout) clearTimeout(this.resizeTimeout);\r\n      const vw = window.innerWidth;\r\n      if(vw !== this._cachedVWValue || force) {\r\n        this._cachedViewportValues = null;\r\n        this._cachedAnimationKeys = null;\r\n        this.resizeTimeout = setTimeout(() => {\r\n          this._cachedVWValue = vw;\r\n          this.rebuild.bind(this)();\r\n        }, 200);\r\n      }\r\n    }\r\n\r\n    scrollControl(event) {\r\n      this.onScroll(event);\r\n    }\r\n\r\n    resizeControl(event) {\r\n      this.resize();\r\n    }\r\n\r\n    setEvents(){\r\n      const { onUpdate, onStart, onComplete } = this.customEvents;\r\n\r\n      // Guardar referencias para poder removerlas después\r\n      this._boundScrollControl = this.scrollControl.bind(this);\r\n      this._boundResizeControl = this.resizeControl.bind(this);\r\n      this._boundOnUpdate = this.onUpdate.bind(this);\r\n      this._boundOnStart = this.onStart.bind(this);\r\n      this._boundOnComplete = this.onComplete.bind(this);\r\n\r\n      window.addEventListener(EVENTS.globalScroll, this._boundScrollControl);\r\n      window.addEventListener(EVENTS.globalResize, this._boundResizeControl);\r\n      \r\n      this.elements.container.addEventListener(onUpdate, this._boundOnUpdate);\r\n      this.elements.container.addEventListener(onStart, this._boundOnStart);\r\n      this.elements.container.addEventListener(onComplete, this._boundOnComplete);\r\n    }\r\n\r\n    getTopDetectionRange(){\r\n      const { detectionMode } = this.options;\r\n      const { start } = detectionMode\r\n      const vh = window.innerHeight;\r\n      \r\n      if(start === 'top') return 0;\r\n      if(start === 'center') return vh / 2;\r\n      if(start === 'bottom') return vh;\r\n      return 0;\r\n    }\r\n\r\n    getBottomDetectionRange(){\r\n      const { detectionMode } = this.options;\r\n      const { end } = detectionMode\r\n      const vh = window.innerHeight;\r\n\r\n      if(end === 'top') return vh * -1;\r\n      if(end === 'center') return (vh / 2) * -1;\r\n      if(end === 'bottom') return 0;\r\n      return 0;\r\n    }\r\n\r\n    getElementCords() {\r\n      const scrollY = window.scrollY || window.pageYOffset;\r\n      const { container } = this.elements;\r\n      const { startAt, endAt } = this.scrollCords;\r\n      const { scrollDistance, fullscreen } = this.options;\r\n      \r\n      // Cache valores que no cambian durante el scroll\r\n      if (!this._cachedViewportValues) {\r\n        this._cachedViewportValues = {\r\n          vh: window.innerHeight,\r\n          scaleDistance: !fullscreen ? scrollDistance * 0.01 : 0,\r\n          topDetectionRange: this.getTopDetectionRange(),\r\n          bottomDetectionRange: this.getBottomDetectionRange()\r\n        };\r\n      }\r\n      \r\n      const { vh, scaleDistance, topDetectionRange, bottomDetectionRange } = this._cachedViewportValues;\r\n      \r\n      const containerRect = container.getBoundingClientRect();\r\n      let containerTop = containerRect.top + scrollY;\r\n      let containerBottom = containerRect.bottom + scrollY;\r\n      containerBottom += (vh * scaleDistance);\r\n\r\n      let screenTop = scrollY + topDetectionRange;\r\n      let screenBottom = scrollY + vh + bottomDetectionRange;\r\n\r\n      let distanceToStart = (containerTop - startAt) - screenTop;\r\n      let distanceToEnd = (containerBottom + endAt) - screenBottom;\r\n\r\n      return { \r\n        top: containerTop, \r\n        height: containerRect.height,\r\n        totalSpace: containerBottom - containerTop,\r\n        bottom: containerBottom, \r\n        toStart: distanceToStart,\r\n        toEnd: distanceToEnd\r\n      };\r\n    }\r\n\r\n    onScroll(event) {\r\n      if (!this.interfaceReady) return;\r\n      const { toStart, toEnd } = this.getElementCords();\r\n\r\n      let progress = 0;\r\n\r\n      if (toStart <= 0 && toEnd >= 0) {\r\n        const totalDistance = Math.abs(toStart) + Math.abs(toEnd);\r\n        const currentDistance = Math.abs(toStart);\r\n        progress = totalDistance > 0 ? currentDistance / totalDistance : 0;\r\n      } else if (toStart > 0) {\r\n        progress = 0;\r\n      } else if (toEnd < 0) {\r\n        progress = 1;\r\n      }\r\n\r\n      progress = Math.max(0, Math.min(1, progress));\r\n\r\n      // Solo actualizar si el progreso cambió significativamente\r\n      const progressDiff = Math.abs(this.progress - progress);\r\n      if (progressDiff < 0.001 && this.previousProgress !== undefined) {\r\n        return;\r\n      }\r\n\r\n      const { container } = this.elements;\r\n      const { scrollTop } = this.options;\r\n      const progressReverse = 1 - progress;\r\n      \r\n      this.previousProgress = this.progress;\r\n      this.progress = progress;\r\n      this.progressReverse = progressReverse;\r\n\r\n      // Reutilizar objeto en lugar de crear nuevo\r\n      const eventDetail = this._eventDetailPool;\r\n      eventDetail.progress = progress;\r\n      eventDetail.scrollTop = scrollTop;\r\n      eventDetail.progressReverse = progressReverse;\r\n      eventDetail.containerRect = null; // Se calculará solo si se necesita\r\n\r\n      // Función lazy para containerRect\r\n      const getContainerRect = () => {\r\n        if (!eventDetail.containerRect) {\r\n          eventDetail.containerRect = container.getBoundingClientRect();\r\n        }\r\n        return eventDetail.containerRect;\r\n      };\r\n\r\n      // trigger events\r\n      const { onUpdate, onStart, onComplete } = this.customEvents;\r\n\r\n      // Disparar evento de start cuando la animación comience\r\n      if (progress > 0 && !this.hasStarted) {\r\n        this.hasStarted = true;\r\n        getContainerRect(); // Asegurar que se calcule para el evento\r\n        this.elements.container.dispatchEvent(new CustomEvent(onStart, {\r\n          detail: { ...eventDetail, containerRect: eventDetail.containerRect }\r\n        }));\r\n      }\r\n      \r\n      if (((toStart >= 0 && toEnd >= 0) || (toStart < 0 && toEnd < 0)) && this.progressEnded !== false) {\r\n        return;\r\n      }\r\n\r\n      this.elements.container.dispatchEvent(new CustomEvent(onUpdate, {\r\n        detail: { ...eventDetail, containerRect: getContainerRect(), scrollEvent: event }\r\n      }));\r\n\r\n      if (progress === 1 && this.previousProgress < 1) {\r\n        getContainerRect();\r\n        this.elements.container.dispatchEvent(new CustomEvent(onComplete, {\r\n          detail: { ...eventDetail, containerRect: eventDetail.containerRect }\r\n        }));\r\n      }\r\n    }\r\n\r\n    onUpdate(event) {\r\n        const { progress } = event.detail;\r\n\r\n        this.progressEnded = progress === 1 ? 1 : (progress === 0 ? 0 : false);\r\n\r\n        if (progress === 0) {\r\n          this.hasStarted = false;\r\n        }\r\n\r\n        // Cache de arrays para evitar Object.keys() repetido\r\n        if (!this._cachedAnimationKeys) {\r\n          this._cachedAnimationKeys = {\r\n            custom: Object.keys(this.customAnimations),\r\n            timeline: Object.keys(this.timeline)\r\n          };\r\n        }\r\n\r\n        const { custom: customAnimations } = this._cachedAnimationKeys;\r\n\r\n        // Ejecutar animaciones personalizadas\r\n        customAnimations.forEach(animation => {\r\n          this.customAnimations[animation].call(this);\r\n        });\r\n\r\n        this.props.onUpdate && this.props.onUpdate.call(this, event);\r\n    }\r\n\r\n    onStart(event) {\r\n      this.props.onStart && this.props.onStart.call(this, event);\r\n      //console.log('Animation started');\r\n    }\r\n\r\n    onComplete(event) {\r\n      this.props.onComplete && this.props.onComplete.call(this, event);\r\n      //console.log('Animation completed');\r\n    }\r\n\r\n    normalizedProgress(start, end, progress = this.progress){\r\n      return Math.max(0, Math.min(1, (progress - start) / (end - start)));\r\n    }\r\n\r\n    getPercentElement(element, options = {}) {\r\n      if(!element) {\r\n        console.warn('Element is not defined');\r\n        return 0;\r\n      }\r\n      \r\n      // Opciones de configuración\r\n      const {\r\n          mode = 'start',           // 'start', 'center', 'end', 'visible'\r\n          offset = 0,               // Offset adicional en píxeles\r\n          threshold = 0.5,          // Para modo 'visible' (0-1)\r\n          cache = true              // Usar cache para optimizar\r\n      } = options;\r\n\r\n      // Cache key para evitar recálculos innecesarios\r\n      const cacheKey = `${element.className || 'element'}-${mode}-${offset}-${threshold}`;\r\n      \r\n      if (cache && this._elementPercentCache && this._elementPercentCache[cacheKey]) {\r\n          return this._elementPercentCache[cacheKey];\r\n      }\r\n\r\n      try {\r\n          const { container } = this.elements;\r\n          const { scrollDistance, fullscreen } = this.options;\r\n          \r\n          // Obtener coordenadas del container y elemento\r\n          const containerRect = container.getBoundingClientRect();\r\n          const containerScrollTop = container.scrollTop || 0;\r\n          const containerTop = containerRect.top + window.scrollY - containerScrollTop;\r\n          \r\n          const elementRect = element.getBoundingClientRect();\r\n          const elementScrollTop = element.scrollTop || 0;\r\n          const elementTop = elementRect.top + window.scrollY - elementScrollTop;\r\n          \r\n          // Calcular altura total del container (incluyendo scroll distance)\r\n          const vh = window.innerHeight;\r\n          const scaleDistance = !fullscreen ? scrollDistance * 0.01 : 0;\r\n          const totalContainerHeight = containerRect.height + (vh * scaleDistance);\r\n          \r\n          // Posición relativa del elemento dentro del container\r\n          let relativeElementPosition = elementTop - containerTop + offset;\r\n          \r\n          // Ajustar según el modo de cálculo\r\n          switch(mode) {\r\n              case 'start':\r\n                  // Cuando el elemento comience a aparecer\r\n                  relativeElementPosition += 0;\r\n                  break;\r\n                  \r\n              case 'center':\r\n                  // Cuando el centro del elemento esté visible\r\n                  relativeElementPosition += elementRect.height / 2;\r\n                  break;\r\n                  \r\n              case 'end':\r\n                  // Cuando el elemento termine de aparecer\r\n                  relativeElementPosition += elementRect.height;\r\n                  break;\r\n                  \r\n              case 'visible':\r\n                  // Cuando un threshold del elemento sea visible\r\n                  relativeElementPosition += elementRect.height * threshold;\r\n                  break;\r\n                  \r\n              default:\r\n                  relativeElementPosition += 0;\r\n          }\r\n          \r\n          // Calcular el porcentaje (0-1) dentro del total del container\r\n          const percentage = Math.max(0, Math.min(1, relativeElementPosition / totalContainerHeight));\r\n          \r\n          // Convertir a progreso del scroll (0-100)\r\n          const scrollProgress = percentage * 100;\r\n          \r\n          // Guardar en cache\r\n          if (cache) {\r\n              if (!this._elementPercentCache) {\r\n                  this._elementPercentCache = {};\r\n              }\r\n              this._elementPercentCache[cacheKey] = scrollProgress;\r\n          }\r\n          \r\n          return scrollProgress;\r\n          \r\n      } catch (error) {\r\n          console.warn('Error calculating element percentage:', error);\r\n          return 0;\r\n      }\r\n    }\r\n    \r\n    setProgress(progress, callback) {\r\n      this.progress = progress;\r\n      const { onUpdate } = this.customEvents;\r\n      \r\n      this.elements.container.dispatchEvent(new CustomEvent(onUpdate, {\r\n        detail: {\r\n          container: this.container,\r\n          progress: progress\r\n        }\r\n      }));\r\n\r\n      setTimeout(callback, 200);\r\n    }\r\n\r\n    destroy() {\r\n      if (this._boundScrollControl) {\r\n          window.removeEventListener(EVENTS.globalScroll, this._boundScrollControl);\r\n      }\r\n      if (this._boundResizeControl) {\r\n          window.removeEventListener(EVENTS.globalResize, this._boundResizeControl);\r\n      }\r\n      \r\n      const { onUpdate, onStart, onComplete } = this.customEvents;\r\n      if (this._boundOnUpdate) {\r\n          this.elements.container.removeEventListener(onUpdate, this._boundOnUpdate);\r\n      }\r\n      if (this._boundOnStart) {\r\n          this.elements.container.removeEventListener(onStart, this._boundOnStart);\r\n      }\r\n      if (this._boundOnComplete) {\r\n          this.elements.container.removeEventListener(onComplete, this._boundOnComplete);\r\n      }\r\n\r\n      // Limpiar referencias\r\n      this._boundScrollControl = null;\r\n      this._boundResizeControl = null;\r\n      this._boundOnUpdate = null;\r\n      this._boundOnStart = null;\r\n      this._boundOnComplete = null;\r\n      \r\n      this.progress = 0;\r\n      this.previousProgress = 0;\r\n      this.progressEnded = false;\r\n      this._cachedViewportValues = null;\r\n      this._cachedAnimationKeys = null;\r\n      this.interfaceReady = false;\r\n    }\r\n\r\n    rebuild(){\r\n      this.destroy();\r\n      this.init()\r\n    }\r\n}\r\n\r\nclass TLH {\r\n  constructor () {\r\n    this.instances = {};\r\n\r\n    this.helpers = new Helpers();\r\n\r\n    this.setEvents()\r\n  }\r\n\r\n  _createOptimizedScrollHandler() {\r\n      let ticking = false;\r\n      let lastTime = 0;\r\n      \r\n      return (event) => {\r\n        const now = performance.now();\r\n        \r\n        if (now - lastTime < 16.67) return;\r\n        \r\n        if (!ticking) {\r\n          lastTime = now;\r\n          \r\n          requestAnimationFrame(() => {\r\n            const updateEvent = new CustomEvent(EVENTS.globalScroll, { detail: { originalEvent: event } });\r\n            window.dispatchEvent(updateEvent);\r\n            ticking = false;\r\n          });\r\n          \r\n          ticking = true;\r\n        }\r\n      };\r\n  }\r\n\r\n  _createOptimizedResizeHandler(event) {\r\n      let resizeTimeout;\r\n\r\n      return (event) => {\r\n        clearTimeout(resizeTimeout);\r\n        resizeTimeout = setTimeout(() => {\r\n          const updateEvent = new CustomEvent(EVENTS.globalResize, { detail: { originalEvent: event } });\r\n          window.dispatchEvent(updateEvent);\r\n        }, 100);\r\n      };\r\n  }\r\n\r\n  setEvents(){\r\n    window.addEventListener('scroll', this._createOptimizedScrollHandler(), { passive: true });\r\n    window.addEventListener('resize', this._createOptimizedResizeHandler());  \r\n  }\r\n\r\n  createAnimation(container, props = {}) {\r\n    if(!container) {\r\n      console.error('No container element provided for animation.');\r\n      return; \r\n    }\r\n\r\n    let name = props.name;\r\n    if (!name) {\r\n      name = container.getAttribute('data-name') || `instance-${Object.keys(this.instances).length + 1}`;\r\n    }\r\n\r\n    if(this.instances[name]) {\r\n      console.warn(`Instance with name \"${name}\" already exists. Skipping creation. Please set a valid name on props.`);\r\n      return;\r\n    }\r\n\r\n    props.helpers = this.helpers;\r\n\r\n    const instance = new TLHAnimation(container, props);\r\n    this.addInstance(instance, name);\r\n\r\n    return this.instances[name]\r\n  }\r\n\r\n  addInstance(instance, name) {\r\n    this.instances[name] = instance;\r\n  }\r\n\r\n  getInstance(name) {\r\n    return this.instances[name];\r\n  }\r\n}\r\n\r\n// Exportaciones\r\nexport default TLH;\r\nexport {\r\n  TLH,\r\n  TLHAnimation,\r\n  TimeLine,\r\n  Helpers,\r\n  AnimationConstructor,\r\n  EVENTS,\r\n  ELEMENTS_CLASS\r\n};\r\n\r\n// Para compatibilidad con UMD\r\nif (typeof window !== 'undefined') {\r\n  window.TLH = TLH;\r\n}"],"names":["AnimationConstructor","container","props","__spreadValues","Helpers","__publicField","target","element","rect","scrollTop","scrollLeft","position","duration","easing","start","getPosition","change","startTime","animateScroll","currentTime","timeElapsed","progress","val","Animation","animation","e","end","startUnit","endUnit","baseProgress","adjustedProgress","Timeline","parent","name","__spreadProps","EVENTS","ELEMENTS_CLASS","TLHAnimation","TimeLine","vh","newStart","newEnd","top","bottom","endAt","startAt","startMarkerElement","endMarkerElement","startMarker","endMarker","markerStyle","color","pinSection","child","scrollDistance","fullscreen","scaleDistance","windowHeight","contentHeight","newHeight","force","vw","event","onUpdate","onStart","onComplete","detectionMode","scrollY","topDetectionRange","bottomDetectionRange","containerRect","containerTop","containerBottom","screenTop","screenBottom","distanceToStart","distanceToEnd","toStart","toEnd","totalDistance","currentDistance","progressReverse","eventDetail","getContainerRect","customAnimations","options","mode","offset","threshold","cache","cacheKey","containerScrollTop","elementRect","elementScrollTop","elementTop","totalContainerHeight","relativeElementPosition","scrollProgress","error","callback","TLH","ticking","lastTime","now","updateEvent","resizeTimeout","instance"],"mappings":"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"}