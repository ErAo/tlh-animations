{"version":3,"file":"tlh-animations.es.js","sources":["../src/AnimationConstructor.js","../src/Helpers.js","../src/TimeLine.js","../src/ConfigVars.js","../animations.js"],"sourcesContent":["class AnimationConstructor {\r\n    constructor(container, props = {}) {\r\n        this.elements = { // to store DOM elements\r\n            container: container\r\n        };\r\n\r\n        this.customAnimations = props.customAnimations || {} // to define custom animations in child class\r\n\r\n        this.scrollCords = { // to define where the animation starts and ends in relation to the container and viewport\r\n            startAt: 0,\r\n            endAt: 0\r\n        }\r\n\r\n        this._cachedVWValue = window.innerWidth; // to manage resize events\r\n\r\n        this.progress = 0; // from 0 to 1\r\n        this.previousProgress = 0; // to manage update event\r\n        this.progressEnded = false; // to manage complete event\r\n        this.interfaceReady = false; // to wait until the first scroll event\r\n        this.hasStarted = false; // to manage start event\r\n\r\n        this._lastScrollTime = 0; // to manage scroll events\r\n\r\n        this.timeline = {} // to be defined in child class\r\n\r\n        this.options = {\r\n            start: 0, // 0 means when the top of the container hits the bottom of the viewport\r\n            end: 0, // 0 means when the bottom of the container hits the bottom of the viewport\r\n            markers: false, // show markers at start and end positions\r\n            pin: false, // pin the container during the animation\r\n            detectionMode: {\r\n                start: 'top', // top, center, bottom\r\n                end: 'bottom' // top, center, bottom\r\n            }, \r\n            scrollDistance: 0, // this value will be calculated automatically if set to 0\r\n            fullscreen: true, // if true, the animation will take the full height of the viewport * scrollDistance scaled\r\n            ...this.getDataOptions(), // get options from data attributes\r\n            ...props.options // override with props\r\n        }\r\n\r\n        this._eventDetailPool = {\r\n            container,\r\n            progress: 0,\r\n            containerRect: null,\r\n            scrollTop: 0,\r\n            progressReverse: 0\r\n        }\r\n    }\r\n}\r\n\r\nexport default AnimationConstructor;","export default class Helpers {\r\n    static easing =  {\r\n        linear: (t) => t,\r\n        easeIn: (t) => t * t,\r\n        easeOut: (t) => t * (2 - t),\r\n        easeInOut: (t) => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,\r\n        bounce: (t) => {\r\n            if (t < 1/2.75) {\r\n                return 7.5625 * t * t;\r\n            } else if (t < 2/2.75) {\r\n                return 7.5625 * (t -= 1.5/2.75) * t + 0.75;\r\n            } else if (t < 2.5/2.75) {\r\n                return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;\r\n            } else {\r\n                return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Selector helper\r\n    static selector = (target) => {\r\n        if (typeof target === 'string') {\r\n            return document.querySelectorAll(target);\r\n        }\r\n        return [target];\r\n    }\r\n};","class Animation {\r\n    constructor(animation, props) {\r\n        this.name = animation\r\n        this.props = props\r\n\r\n        this.container = props.container || null\r\n\r\n        this.start = props.start ? props.start : 0\r\n        this.end = props.end ? props.end : 100\r\n        this.duration = props.duration ? props.duration : 1\r\n        this.normalizedProgress = 0\r\n        this.hasStarted = false\r\n        this.progressEnded = false\r\n        this.progress = 0\r\n\r\n        if(!this.container) {\r\n            console.error('Container is required for animation:', animation);\r\n            return;\r\n        }\r\n\r\n        this.container.addEventListener(this.props.events.onUpdate, (e) => {\r\n            this.updateTimeline(e.detail.progress);\r\n        });\r\n\r\n        return this\r\n    }\r\n\r\n    onUpdate() {\r\n        if(this.progress === 0){\r\n            this.hasStarted = false;\r\n        }\r\n\r\n        this.progressEnded = this.progress === 1 ? 1 : (this.progress === 0 ? 0 : false);\r\n        if(this.props.onUpdate) this.props.onUpdate.bind(this)();\r\n    }\r\n\r\n    onStart (){\r\n        this.hasStarted = true;\r\n        if(this.props.onStart) this.props.onStart.bind(this)();\r\n    }\r\n\r\n    onComplete(){\r\n        if(this.props.onComplete) this.props.onComplete.bind(this)();\r\n    }\r\n\r\n    updateTimeline(progress) {\r\n        const { start, end, duration } = this;\r\n\r\n        // Cache de valores calculados\r\n        if (!this._cachedUnits) {\r\n            this._cachedUnits = {\r\n                startUnit: start * 0.01,\r\n                endUnit: end * 0.01\r\n            };\r\n        }\r\n        \r\n        const { startUnit, endUnit } = this._cachedUnits;\r\n        const baseProgress = this.props.normalizedProgress(startUnit, endUnit, progress);\r\n\r\n        let adjustedProgress;\r\n        if (duration !== 1) {\r\n        adjustedProgress = Math.pow(baseProgress, duration);\r\n        } else {\r\n        adjustedProgress = baseProgress;\r\n        }\r\n\r\n        adjustedProgress = Math.max(0, Math.min(1, adjustedProgress));\r\n\r\n        this.progress = baseProgress;\r\n        this.normalizedProgress = adjustedProgress;\r\n\r\n        if (this.progress > 0 && !this.hasStarted) {\r\n            this.onStart();\r\n        }\r\n\r\n        this.onUpdate();\r\n\r\n        if (progress === 1) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n}\r\n\r\nexport default class Timeline {\r\n    constructor(parent) {\r\n        this.parent = parent; // Referencia a la instancia padre\r\n        this.elements = parent.elements;\r\n        this.customEvents = parent.customEvents;\r\n        this.normalizedProgress = parent.normalizedProgress;\r\n    }\r\n\r\n    add(name, props) {\r\n        if(!name) {\r\n            console.error('Animation name is required');\r\n            return;\r\n        }\r\n        \r\n        if(!props) {\r\n            console.error('Animation props are required');\r\n            return;\r\n        }\r\n\r\n        return new Animation(name, {\r\n            ...props, \r\n            normalizedProgress: this.normalizedProgress,\r\n            container: this.elements.container, \r\n            events : this.customEvents\r\n        });\r\n    }\r\n}","const EVENTS = {\r\n    onUpdate: 'tlh-animate-update',\r\n    onStart: 'tlh-animate-start',\r\n    onComplete: 'tlh-animate-complete',\r\n    globalScroll: 'tlh-global-scroll',\r\n    globalResize: 'tlh-global-resize'\r\n}\r\n\r\nconst ELEMENTS_CLASS = {\r\n    marker: 'tlh-scroll-marker',\r\n    markerStart: 'tlh-scroll-marker-start',\r\n    markerEnd: 'tlh-scroll-marker-end',\r\n    pinSpacer: 'tlh-pin-section',\r\n    pinInner: 'tlh-pin-inner'\r\n}\r\n\r\nexport { EVENTS, ELEMENTS_CLASS };","import AnimationConstructor from \"./src/AnimationConstructor.js\";\r\nimport Helpers from \"./src/Helpers.js\";\r\nimport TimeLine from \"./src/TimeLine.js\";\r\nimport { EVENTS, ELEMENTS_CLASS } from \"./src/ConfigVars.js\";\r\n\r\nclass TLHAnimation extends AnimationConstructor {\r\n    constructor(container, props = {}) {\r\n      super(container, props);\r\n      this.props = props;\r\n\r\n      this.customEvents = {\r\n          onUpdate: EVENTS.onUpdate,\r\n          onStart: EVENTS.onStart,\r\n          onComplete: EVENTS.onComplete\r\n      };\r\n\r\n      this.timeline = new TimeLine(this);\r\n\r\n      this.init();\r\n    }\r\n\r\n    getDataOptions () {\r\n      const dataOptions = this.elements.container.dataset;\r\n      return dataOptions;\r\n    }\r\n\r\n    init() {\r\n      this.setElements('container', this.elements.container);\r\n      if(this.props.onMounted) this.props.onMounted.call(this);\r\n      this.setScrollCords();\r\n      this.createInterface();\r\n      this.setEvents();\r\n    }\r\n\r\n    setScrollCords() {\r\n      const { end, start } = this.options;\r\n      const vh = window.innerHeight;\r\n\r\n      const newStart = vh * (start * 0.01);\r\n      const newEnd = vh * (end * 0.01);\r\n\r\n      this.scrollCords.startAt = newStart;\r\n      this.scrollCords.endAt = newEnd;\r\n    }\r\n    \r\n    addToTimeline(props) {\r\n      if(!props.name) {\r\n        console.warn('You must provide a name for the timeline animation.');\r\n        return;\r\n      }\r\n\r\n      if(this.timeline[props.name]) {\r\n        console.warn(`Timeline animation with name \"${props.name}\" already exists.`);\r\n        return;\r\n      }\r\n  \r\n      this.timeline.add(props.name, props);\r\n\r\n      this._cachedAnimationKeys = null;\r\n    }\r\n\r\n    setElements(name, element) {\r\n      this.elements[name] = element;\r\n    }\r\n\r\n    addMarkers() {\r\n      if(!this.options.markers) return;\r\n      const { top, bottom } = this.getElementCords();\r\n      const { endAt, startAt } = this.scrollCords;\r\n      const { startMarker: startMarkerElement, endMarker: endMarkerElement } = this.elements;\r\n      const startMarker = startMarkerElement ?? document.createElement('div');\r\n      const endMarker = endMarkerElement ?? document.createElement('div');\r\n      startMarker.classList.add(ELEMENTS_CLASS.marker, ELEMENTS_CLASS.markerStart);\r\n      endMarker.classList.add(ELEMENTS_CLASS.marker, ELEMENTS_CLASS.markerEnd);\r\n      const { end, start } = this.options.detectionMode;\r\n\r\n      const markerStyle = (top, color) => `\r\n        position: absolute;\r\n        left: 0;\r\n        right: 0;\r\n        top: ${top}px;\r\n        width: 100%;\r\n        height: 2px;\r\n        z-index: 9999;\r\n        background: ${color};\r\n      `;\r\n\r\n      startMarker.style.cssText = markerStyle(top - startAt, 'green');\r\n      endMarker.style.cssText = markerStyle(bottom + endAt, 'red');\r\n\r\n      startMarker.textContent = `Start - once this touch the ${start} of the viewport`;\r\n      endMarker.textContent = `End - once this touch the ${end} of the viewport`;\r\n      \r\n      if(!startMarkerElement && !endMarkerElement) {\r\n        document.body.append(startMarker);\r\n        document.body.append(endMarker);\r\n        this.setElements('startMarker', startMarker);\r\n        this.setElements('endMarker', endMarker);\r\n      }\r\n    }\r\n\r\n    createPinInterface() {\r\n      const pinSection = document.createElement('div');\r\n      pinSection.classList.add(ELEMENTS_CLASS.pinSpacer);\r\n      pinSection.style.cssText = `\r\n        position: sticky;\r\n        top: 0;\r\n        height: 100vh;\r\n        width: 100%;\r\n        pointer-events: none;\r\n      `;\r\n\r\n      const children = Array.from(this.elements.container.childNodes);\r\n      children.forEach(child => {\r\n        pinSection.appendChild(child);\r\n      });\r\n\r\n      this.elements.container.appendChild(pinSection);\r\n    }\r\n\r\n    createInterface() {\r\n      const { container } = this.elements;\r\n      const { scrollDistance, fullscreen } = this.options;\r\n      const { endAt } = this.scrollCords;\r\n      const scaleDistance = scrollDistance * 0.01;\r\n      const windowHeight = window.innerHeight;\r\n\r\n      if(!scrollDistance && scrollDistance != 0) {\r\n        console.warn('scrollDistance must be defined on element or animation options');\r\n      }\r\n\r\n      const contentHeight = (windowHeight * scaleDistance);\r\n      \r\n      this.options.scrollTop = (contentHeight + endAt);\r\n      if(scrollDistance > 0 && fullscreen) {\r\n        const newHeight = windowHeight + contentHeight;\r\n        container.style.height = `${newHeight}px`;\r\n      }\r\n\r\n      this.interfaceReady = true\r\n\r\n      this.addMarkers()\r\n      if(this.options.pin) this.createPinInterface()\r\n    }\r\n\r\n    resize(force = false) {\r\n      if(this.resizeTimeout) clearTimeout(this.resizeTimeout);\r\n      const vw = window.innerWidth;\r\n      if(vw !== this._cachedVWValue || force) {\r\n        this._cachedViewportValues = null;\r\n        this._cachedAnimationKeys = null;\r\n        this.resizeTimeout = setTimeout(() => {\r\n          this._cachedVWValue = vw;\r\n          this.rebuild.bind(this)();\r\n        }, 200);\r\n      }\r\n    }\r\n\r\n    scrollControl(event) {\r\n      this.onScroll(event);\r\n    }\r\n\r\n    resizeControl(event) {\r\n      this.resize();\r\n    }\r\n\r\n    setEvents(){\r\n      const { onUpdate, onStart, onComplete } = this.customEvents;\r\n\r\n      // Guardar referencias para poder removerlas después\r\n      this._boundScrollControl = this.scrollControl.bind(this);\r\n      this._boundResizeControl = this.resizeControl.bind(this);\r\n      this._boundOnUpdate = this.onUpdate.bind(this);\r\n      this._boundOnStart = this.onStart.bind(this);\r\n      this._boundOnComplete = this.onComplete.bind(this);\r\n\r\n      window.addEventListener(EVENTS.globalScroll, this._boundScrollControl);\r\n      window.addEventListener(EVENTS.globalResize, this._boundResizeControl);\r\n      \r\n      this.elements.container.addEventListener(onUpdate, this._boundOnUpdate);\r\n      this.elements.container.addEventListener(onStart, this._boundOnStart);\r\n      this.elements.container.addEventListener(onComplete, this._boundOnComplete);\r\n    }\r\n\r\n    getTopDetectionRange(){\r\n      const { detectionMode } = this.options;\r\n      const { start } = detectionMode\r\n      const vh = window.innerHeight;\r\n      \r\n      if(start === 'top') return 0;\r\n      if(start === 'center') return vh / 2;\r\n      if(start === 'bottom') return vh;\r\n      return 0;\r\n    }\r\n\r\n    getBottomDetectionRange(){\r\n      const { detectionMode } = this.options;\r\n      const { end } = detectionMode\r\n      const vh = window.innerHeight;\r\n\r\n      if(end === 'top') return vh * -1;\r\n      if(end === 'center') return (vh / 2) * -1;\r\n      if(end === 'bottom') return 0;\r\n      return 0;\r\n    }\r\n\r\n    getElementCords() {\r\n      const scrollY = window.scrollY || window.pageYOffset;\r\n      const { container } = this.elements;\r\n      const { startAt, endAt } = this.scrollCords;\r\n      const { scrollDistance, fullscreen } = this.options;\r\n      \r\n      // Cache valores que no cambian durante el scroll\r\n      if (!this._cachedViewportValues) {\r\n        this._cachedViewportValues = {\r\n          vh: window.innerHeight,\r\n          scaleDistance: !fullscreen ? scrollDistance * 0.01 : 0,\r\n          topDetectionRange: this.getTopDetectionRange(),\r\n          bottomDetectionRange: this.getBottomDetectionRange()\r\n        };\r\n      }\r\n      \r\n      const { vh, scaleDistance, topDetectionRange, bottomDetectionRange } = this._cachedViewportValues;\r\n      \r\n      const containerRect = container.getBoundingClientRect();\r\n      let containerTop = containerRect.top + scrollY;\r\n      let containerBottom = containerRect.bottom + scrollY;\r\n      containerBottom += (vh * scaleDistance);\r\n\r\n      let screenTop = scrollY + topDetectionRange;\r\n      let screenBottom = scrollY + vh + bottomDetectionRange;\r\n\r\n      let distanceToStart = (containerTop - startAt) - screenTop;\r\n      let distanceToEnd = (containerBottom + endAt) - screenBottom;\r\n\r\n      return { \r\n        top: containerTop, \r\n        height: containerRect.height,\r\n        totalSpace: containerBottom - containerTop,\r\n        bottom: containerBottom, \r\n        toStart: distanceToStart,\r\n        toEnd: distanceToEnd\r\n      };\r\n    }\r\n\r\n    onScroll(event) {\r\n      if (!this.interfaceReady) return;\r\n      const { toStart, toEnd } = this.getElementCords();\r\n\r\n      let progress = 0;\r\n\r\n      if (toStart <= 0 && toEnd >= 0) {\r\n        const totalDistance = Math.abs(toStart) + Math.abs(toEnd);\r\n        const currentDistance = Math.abs(toStart);\r\n        progress = totalDistance > 0 ? currentDistance / totalDistance : 0;\r\n      } else if (toStart > 0) {\r\n        progress = 0;\r\n      } else if (toEnd < 0) {\r\n        progress = 1;\r\n      }\r\n\r\n      progress = Math.max(0, Math.min(1, progress));\r\n\r\n      // Solo actualizar si el progreso cambió significativamente\r\n      const progressDiff = Math.abs(this.progress - progress);\r\n      if (progressDiff < 0.001 && this.previousProgress !== undefined) {\r\n        return;\r\n      }\r\n\r\n      const { container } = this.elements;\r\n      const { scrollTop } = this.options;\r\n      const progressReverse = 1 - progress;\r\n      \r\n      this.previousProgress = this.progress;\r\n      this.progress = progress;\r\n      this.progressReverse = progressReverse;\r\n\r\n      // Reutilizar objeto en lugar de crear nuevo\r\n      const eventDetail = this._eventDetailPool;\r\n      eventDetail.progress = progress;\r\n      eventDetail.scrollTop = scrollTop;\r\n      eventDetail.progressReverse = progressReverse;\r\n      eventDetail.containerRect = null; // Se calculará solo si se necesita\r\n\r\n      // Función lazy para containerRect\r\n      const getContainerRect = () => {\r\n        if (!eventDetail.containerRect) {\r\n          eventDetail.containerRect = container.getBoundingClientRect();\r\n        }\r\n        return eventDetail.containerRect;\r\n      };\r\n\r\n      // trigger events\r\n      const { onUpdate, onStart, onComplete } = this.customEvents;\r\n\r\n      // Disparar evento de start cuando la animación comience\r\n      if (progress > 0 && !this.hasStarted) {\r\n        this.hasStarted = true;\r\n        getContainerRect(); // Asegurar que se calcule para el evento\r\n        this.elements.container.dispatchEvent(new CustomEvent(onStart, {\r\n          detail: { ...eventDetail, containerRect: eventDetail.containerRect }\r\n        }));\r\n      }\r\n      \r\n      if (((toStart >= 0 && toEnd >= 0) || (toStart < 0 && toEnd < 0)) && this.progressEnded !== false) {\r\n        return;\r\n      }\r\n\r\n      this.elements.container.dispatchEvent(new CustomEvent(onUpdate, {\r\n        detail: { ...eventDetail, containerRect: getContainerRect(), scrollEvent: event }\r\n      }));\r\n\r\n      if (progress === 1 && this.previousProgress < 1) {\r\n        getContainerRect();\r\n        this.elements.container.dispatchEvent(new CustomEvent(onComplete, {\r\n          detail: { ...eventDetail, containerRect: eventDetail.containerRect }\r\n        }));\r\n      }\r\n    }\r\n\r\n    onUpdate(event) {\r\n        const { progress } = event.detail;\r\n\r\n        this.progressEnded = progress === 1 ? 1 : (progress === 0 ? 0 : false);\r\n\r\n        if (progress === 0) {\r\n          this.hasStarted = false;\r\n        }\r\n\r\n        // Cache de arrays para evitar Object.keys() repetido\r\n        if (!this._cachedAnimationKeys) {\r\n          this._cachedAnimationKeys = {\r\n            custom: Object.keys(this.customAnimations),\r\n            timeline: Object.keys(this.timeline)\r\n          };\r\n        }\r\n\r\n        const { custom: customAnimations } = this._cachedAnimationKeys;\r\n\r\n        // Ejecutar animaciones personalizadas\r\n        customAnimations.forEach(animation => {\r\n          this.customAnimations[animation].call(this);\r\n        });\r\n\r\n        this.props.onUpdate && this.props.onUpdate.call(this, event);\r\n    }\r\n\r\n    onStart(event) {\r\n      this.props.onStart && this.props.onStart.call(this, event);\r\n      //console.log('Animation started');\r\n    }\r\n\r\n    onComplete(event) {\r\n      this.props.onComplete && this.props.onComplete.call(this, event);\r\n      //console.log('Animation completed');\r\n    }\r\n\r\n    normalizedProgress(start, end, progress = this.progress){\r\n      return Math.max(0, Math.min(1, (progress - start) / (end - start)));\r\n    }\r\n\r\n    getPercentElement(element, options = {}) {\r\n      if(!element) {\r\n        console.warn('Element is not defined');\r\n        return 0;\r\n      }\r\n      \r\n      // Opciones de configuración\r\n      const {\r\n          mode = 'start',           // 'start', 'center', 'end', 'visible'\r\n          offset = 0,               // Offset adicional en píxeles\r\n          threshold = 0.5,          // Para modo 'visible' (0-1)\r\n          cache = true              // Usar cache para optimizar\r\n      } = options;\r\n\r\n      // Cache key para evitar recálculos innecesarios\r\n      const cacheKey = `${element.className || 'element'}-${mode}-${offset}-${threshold}`;\r\n      \r\n      if (cache && this._elementPercentCache && this._elementPercentCache[cacheKey]) {\r\n          return this._elementPercentCache[cacheKey];\r\n      }\r\n\r\n      try {\r\n          const { container } = this.elements;\r\n          const { scrollDistance, fullscreen } = this.options;\r\n          \r\n          // Obtener coordenadas del container y elemento\r\n          const containerRect = container.getBoundingClientRect();\r\n          const containerScrollTop = container.scrollTop || 0;\r\n          const containerTop = containerRect.top + window.scrollY - containerScrollTop;\r\n          \r\n          const elementRect = element.getBoundingClientRect();\r\n          const elementScrollTop = element.scrollTop || 0;\r\n          const elementTop = elementRect.top + window.scrollY - elementScrollTop;\r\n          \r\n          // Calcular altura total del container (incluyendo scroll distance)\r\n          const vh = window.innerHeight;\r\n          const scaleDistance = !fullscreen ? scrollDistance * 0.01 : 0;\r\n          const totalContainerHeight = containerRect.height + (vh * scaleDistance);\r\n          \r\n          // Posición relativa del elemento dentro del container\r\n          let relativeElementPosition = elementTop - containerTop + offset;\r\n          \r\n          // Ajustar según el modo de cálculo\r\n          switch(mode) {\r\n              case 'start':\r\n                  // Cuando el elemento comience a aparecer\r\n                  relativeElementPosition += 0;\r\n                  break;\r\n                  \r\n              case 'center':\r\n                  // Cuando el centro del elemento esté visible\r\n                  relativeElementPosition += elementRect.height / 2;\r\n                  break;\r\n                  \r\n              case 'end':\r\n                  // Cuando el elemento termine de aparecer\r\n                  relativeElementPosition += elementRect.height;\r\n                  break;\r\n                  \r\n              case 'visible':\r\n                  // Cuando un threshold del elemento sea visible\r\n                  relativeElementPosition += elementRect.height * threshold;\r\n                  break;\r\n                  \r\n              default:\r\n                  relativeElementPosition += 0;\r\n          }\r\n          \r\n          // Calcular el porcentaje (0-1) dentro del total del container\r\n          const percentage = Math.max(0, Math.min(1, relativeElementPosition / totalContainerHeight));\r\n          \r\n          // Convertir a progreso del scroll (0-100)\r\n          const scrollProgress = percentage * 100;\r\n          \r\n          // Guardar en cache\r\n          if (cache) {\r\n              if (!this._elementPercentCache) {\r\n                  this._elementPercentCache = {};\r\n              }\r\n              this._elementPercentCache[cacheKey] = scrollProgress;\r\n          }\r\n          \r\n          return scrollProgress;\r\n          \r\n      } catch (error) {\r\n          console.warn('Error calculating element percentage:', error);\r\n          return 0;\r\n      }\r\n    }\r\n    \r\n    setProgress(progress, callback) {\r\n      this.progress = progress;\r\n      const { onUpdate } = this.customEvents;\r\n      \r\n      this.elements.container.dispatchEvent(new CustomEvent(onUpdate, {\r\n        detail: {\r\n          container: this.container,\r\n          progress: progress\r\n        }\r\n      }));\r\n\r\n      setTimeout(callback, 200);\r\n    }\r\n\r\n    destroy() {\r\n      if (this._boundScrollControl) {\r\n          window.removeEventListener(EVENTS.globalScroll, this._boundScrollControl);\r\n      }\r\n      if (this._boundResizeControl) {\r\n          window.removeEventListener(EVENTS.globalResize, this._boundResizeControl);\r\n      }\r\n      \r\n      const { onUpdate, onStart, onComplete } = this.customEvents;\r\n      if (this._boundOnUpdate) {\r\n          this.elements.container.removeEventListener(onUpdate, this._boundOnUpdate);\r\n      }\r\n      if (this._boundOnStart) {\r\n          this.elements.container.removeEventListener(onStart, this._boundOnStart);\r\n      }\r\n      if (this._boundOnComplete) {\r\n          this.elements.container.removeEventListener(onComplete, this._boundOnComplete);\r\n      }\r\n\r\n      // Limpiar referencias\r\n      this._boundScrollControl = null;\r\n      this._boundResizeControl = null;\r\n      this._boundOnUpdate = null;\r\n      this._boundOnStart = null;\r\n      this._boundOnComplete = null;\r\n      \r\n      this.progress = 0;\r\n      this.previousProgress = 0;\r\n      this.progressEnded = false;\r\n      this._cachedViewportValues = null;\r\n      this._cachedAnimationKeys = null;\r\n      this.interfaceReady = false;\r\n    }\r\n\r\n    rebuild(){\r\n      this.destroy();\r\n      this.init()\r\n    }\r\n}\r\n\r\nclass TLH {\r\n  constructor () {\r\n    this.instances = {};\r\n\r\n    this.setEvents()\r\n  }\r\n\r\n  _createOptimizedScrollHandler() {\r\n      let ticking = false;\r\n      let lastTime = 0;\r\n      \r\n      return (event) => {\r\n        const now = performance.now();\r\n        \r\n        if (now - lastTime < 16.67) return;\r\n        \r\n        if (!ticking) {\r\n          lastTime = now;\r\n          \r\n          requestAnimationFrame(() => {\r\n            const updateEvent = new CustomEvent(EVENTS.globalScroll, { detail: { originalEvent: event } });\r\n            window.dispatchEvent(updateEvent);\r\n            ticking = false;\r\n          });\r\n          \r\n          ticking = true;\r\n        }\r\n      };\r\n  }\r\n\r\n  _createOptimizedResizeHandler(event) {\r\n      let resizeTimeout;\r\n\r\n      return (event) => {\r\n        clearTimeout(resizeTimeout);\r\n        resizeTimeout = setTimeout(() => {\r\n          const updateEvent = new CustomEvent(EVENTS.globalResize, { detail: { originalEvent: event } });\r\n          window.dispatchEvent(updateEvent);\r\n        }, 100);\r\n      };\r\n  }\r\n\r\n  setEvents(){\r\n    window.addEventListener('scroll', this._createOptimizedScrollHandler(), { passive: true });\r\n    window.addEventListener('resize', this._createOptimizedResizeHandler());  \r\n  }\r\n\r\n  createAnimation(container, props = {}) {\r\n    if(!container) {\r\n      console.error('No container element provided for animation.');\r\n      return; \r\n    }\r\n\r\n    let name = props.name;\r\n    if (!name) {\r\n      name = container.getAttribute('data-name') || `instance-${Object.keys(this.instances).length + 1}`;\r\n    }\r\n\r\n    if(this.instances[name]) {\r\n      console.warn(`Instance with name \"${name}\" already exists. Skipping creation. Please set a valid name on props.`);\r\n      return;\r\n    }\r\n\r\n    const instance = new TLHAnimation(container, props);\r\n    this.addInstance(instance, name);\r\n\r\n    return this.instances[name]\r\n  }\r\n\r\n  addInstance(instance, name) {\r\n    this.instances[name] = instance;\r\n  }\r\n\r\n  getInstance(name) {\r\n    return this.instances[name];\r\n  }\r\n}\r\n\r\n// Exportaciones\r\nexport default TLH;\r\nexport {\r\n  TLH,\r\n  TLHAnimation,\r\n  TimeLine,\r\n  Helpers,\r\n  AnimationConstructor,\r\n  EVENTS,\r\n  ELEMENTS_CLASS\r\n};\r\n\r\n// Para compatibilidad con UMD\r\nif (typeof window !== 'undefined') {\r\n  window.TLH = TLH;\r\n}"],"names":["AnimationConstructor","container","props","__spreadValues","Helpers","__publicField","target","Animation","animation","e","progress","start","end","duration","startUnit","endUnit","baseProgress","adjustedProgress","Timeline","parent","name","__spreadProps","EVENTS","ELEMENTS_CLASS","TLHAnimation","TimeLine","vh","newStart","newEnd","element","top","bottom","endAt","startAt","startMarkerElement","endMarkerElement","startMarker","endMarker","markerStyle","color","pinSection","child","scrollDistance","fullscreen","scaleDistance","windowHeight","contentHeight","newHeight","force","vw","event","onUpdate","onStart","onComplete","detectionMode","scrollY","topDetectionRange","bottomDetectionRange","containerRect","containerTop","containerBottom","screenTop","screenBottom","distanceToStart","distanceToEnd","toStart","toEnd","totalDistance","currentDistance","scrollTop","progressReverse","eventDetail","getContainerRect","customAnimations","options","mode","offset","threshold","cache","cacheKey","containerScrollTop","elementRect","elementScrollTop","elementTop","totalContainerHeight","relativeElementPosition","scrollProgress","error","callback","TLH","ticking","lastTime","now","updateEvent","resizeTimeout","instance"],"mappings":";;;;;;;;;;;;;AAAA,MAAMA,EAAqB;AAAA,EACvB,YAAYC,GAAWC,IAAQ,IAAI;AAC/B,SAAK,WAAW;AAAA;AAAA,MACZ,WAAWD;AAAA,IACvB,GAEQ,KAAK,mBAAmBC,EAAM,oBAAoB,CAAA,GAElD,KAAK,cAAc;AAAA;AAAA,MACf,SAAS;AAAA,MACT,OAAO;AAAA,IACnB,GAEQ,KAAK,iBAAiB,OAAO,YAE7B,KAAK,WAAW,GAChB,KAAK,mBAAmB,GACxB,KAAK,gBAAgB,IACrB,KAAK,iBAAiB,IACtB,KAAK,aAAa,IAElB,KAAK,kBAAkB,GAEvB,KAAK,WAAW,CAAA,GAEhB,KAAK,UAAUC,IAAA;AAAA,MACX,OAAO;AAAA;AAAA,MACP,KAAK;AAAA;AAAA,MACL,SAAS;AAAA;AAAA,MACT,KAAK;AAAA;AAAA,MACL,eAAe;AAAA,QACX,OAAO;AAAA;AAAA,QACP,KAAK;AAAA;AAAA,MACrB;AAAA,MACY,gBAAgB;AAAA;AAAA,MAChB,YAAY;AAAA,OACT,KAAK,eAAc,IACnBD,EAAM,UAGb,KAAK,mBAAmB;AAAA,MACpB,WAAAD;AAAA,MACA,UAAU;AAAA,MACV,eAAe;AAAA,MACf,WAAW;AAAA,MACX,iBAAiB;AAAA,IAC7B;AAAA,EACI;AACJ;AChDe,MAAMG,EAAQ;AA0B7B;AAzBIC,EADiBD,GACV,UAAU;AAAA,EACb,QAAQ,CAAC,MAAM;AAAA,EACf,QAAQ,CAAC,MAAM,IAAI;AAAA,EACnB,SAAS,CAAC,MAAM,KAAK,IAAI;AAAA,EACzB,WAAW,CAAC,MAAM,IAAI,MAAM,IAAI,IAAI,IAAI,MAAM,IAAI,IAAI,KAAK;AAAA,EAC3D,QAAQ,CAAC,MACD,IAAI,IAAE,OACC,SAAS,IAAI,IACb,IAAI,IAAE,OACN,UAAU,KAAK,MAAI,QAAQ,IAAI,OAC/B,IAAI,MAAI,OACR,UAAU,KAAK,OAAK,QAAQ,IAAI,SAEhC,UAAU,KAAK,QAAM,QAAQ,IAAI;AAGxD;AAGIC,EApBiBD,GAoBV,YAAW,CAACE,MACX,OAAOA,KAAW,WACX,SAAS,iBAAiBA,CAAM,IAEpC,CAACA,CAAM;ACxBtB,MAAMC,EAAU;AAAA,EACZ,YAAYC,GAAWN,GAAO;AAc1B,QAbA,KAAK,OAAOM,GACZ,KAAK,QAAQN,GAEb,KAAK,YAAYA,EAAM,aAAa,MAEpC,KAAK,QAAQA,EAAM,QAAQA,EAAM,QAAQ,GACzC,KAAK,MAAMA,EAAM,MAAMA,EAAM,MAAM,KACnC,KAAK,WAAWA,EAAM,WAAWA,EAAM,WAAW,GAClD,KAAK,qBAAqB,GAC1B,KAAK,aAAa,IAClB,KAAK,gBAAgB,IACrB,KAAK,WAAW,GAEb,CAAC,KAAK,WAAW;AAChB,cAAQ,MAAM,wCAAwCM,CAAS;AAC/D;AAAA,IACJ;AAEA,gBAAK,UAAU,iBAAiB,KAAK,MAAM,OAAO,UAAU,CAACC,MAAM;AAC/D,WAAK,eAAeA,EAAE,OAAO,QAAQ;AAAA,IACzC,CAAC,GAEM;AAAA,EACX;AAAA,EAEA,WAAW;AACP,IAAG,KAAK,aAAa,MACjB,KAAK,aAAa,KAGtB,KAAK,gBAAgB,KAAK,aAAa,IAAI,IAAK,KAAK,aAAa,IAAI,IAAI,IACvE,KAAK,MAAM,YAAU,KAAK,MAAM,SAAS,KAAK,IAAI;EACzD;AAAA,EAEA,UAAU;AACN,SAAK,aAAa,IACf,KAAK,MAAM,WAAS,KAAK,MAAM,QAAQ,KAAK,IAAI;EACvD;AAAA,EAEA,aAAY;AACR,IAAG,KAAK,MAAM,cAAY,KAAK,MAAM,WAAW,KAAK,IAAI;EAC7D;AAAA,EAEA,eAAeC,GAAU;AACrB,UAAM,EAAE,OAAAC,GAAO,KAAAC,GAAK,UAAAC,EAAQ,IAAK;AAGjC,IAAK,KAAK,iBACN,KAAK,eAAe;AAAA,MAChB,WAAWF,IAAQ;AAAA,MACnB,SAASC,IAAM;AAAA,IAC/B;AAGQ,UAAM,EAAE,WAAAE,GAAW,SAAAC,MAAY,KAAK,cAC9BC,IAAe,KAAK,MAAM,mBAAmBF,GAAWC,GAASL,CAAQ;AAE/E,QAAIO;AACJ,IAAIJ,MAAa,IACjBI,IAAmB,KAAK,IAAID,GAAcH,CAAQ,IAElDI,IAAmBD,GAGnBC,IAAmB,KAAK,IAAI,GAAG,KAAK,IAAI,GAAGA,CAAgB,CAAC,GAE5D,KAAK,WAAWD,GAChB,KAAK,qBAAqBC,GAEtB,KAAK,WAAW,KAAK,CAAC,KAAK,cAC3B,KAAK,QAAO,GAGhB,KAAK,SAAQ,GAETP,MAAa,KACb,KAAK,WAAU;AAAA,EAEvB;AACJ;AAEe,MAAMQ,EAAS;AAAA,EAC1B,YAAYC,GAAQ;AAChB,SAAK,SAASA,GACd,KAAK,WAAWA,EAAO,UACvB,KAAK,eAAeA,EAAO,cAC3B,KAAK,qBAAqBA,EAAO;AAAA,EACrC;AAAA,EAEA,IAAIC,GAAMlB,GAAO;AACb,QAAG,CAACkB,GAAM;AACN,cAAQ,MAAM,4BAA4B;AAC1C;AAAA,IACJ;AAEA,QAAG,CAAClB,GAAO;AACP,cAAQ,MAAM,8BAA8B;AAC5C;AAAA,IACJ;AAEA,WAAO,IAAIK,EAAUa,GAAMC,EAAAlB,EAAA,IACpBD,IADoB;AAAA,MAEvB,oBAAoB,KAAK;AAAA,MACzB,WAAW,KAAK,SAAS;AAAA,MACzB,QAAS,KAAK;AAAA,IAC1B,EAAS;AAAA,EACL;AACJ;AC7GK,MAACoB,IAAS;AAAA,EACX,UAAU;AAAA,EACV,SAAS;AAAA,EACT,YAAY;AAAA,EACZ,cAAc;AAAA,EACd,cAAc;AAClB,GAEMC,IAAiB;AAAA,EACnB,QAAQ;AAAA,EACR,aAAa;AAAA,EACb,WAAW;AAAA,EACX,WAAW;AAAA,EACX,UAAU;AACd;ACTA,MAAMC,UAAqBxB,EAAqB;AAAA,EAC5C,YAAYC,GAAWC,IAAQ,IAAI;AACjC,UAAMD,GAAWC,CAAK,GACtB,KAAK,QAAQA,GAEb,KAAK,eAAe;AAAA,MAChB,UAAUoB,EAAO;AAAA,MACjB,SAASA,EAAO;AAAA,MAChB,YAAYA,EAAO;AAAA,IAC7B,GAEM,KAAK,WAAW,IAAIG,EAAS,IAAI,GAEjC,KAAK,KAAI;AAAA,EACX;AAAA,EAEA,iBAAkB;AAEhB,WADoB,KAAK,SAAS,UAAU;AAAA,EAE9C;AAAA,EAEA,OAAO;AACL,SAAK,YAAY,aAAa,KAAK,SAAS,SAAS,GAClD,KAAK,MAAM,aAAW,KAAK,MAAM,UAAU,KAAK,IAAI,GACvD,KAAK,eAAc,GACnB,KAAK,gBAAe,GACpB,KAAK,UAAS;AAAA,EAChB;AAAA,EAEA,iBAAiB;AACf,UAAM,EAAE,KAAAb,GAAK,OAAAD,MAAU,KAAK,SACtBe,IAAK,OAAO,aAEZC,IAAWD,KAAMf,IAAQ,OACzBiB,IAASF,KAAMd,IAAM;AAE3B,SAAK,YAAY,UAAUe,GAC3B,KAAK,YAAY,QAAQC;AAAA,EAC3B;AAAA,EAEA,cAAc1B,GAAO;AACnB,QAAG,CAACA,EAAM,MAAM;AACd,cAAQ,KAAK,qDAAqD;AAClE;AAAA,IACF;AAEA,QAAG,KAAK,SAASA,EAAM,IAAI,GAAG;AAC5B,cAAQ,KAAK,iCAAiCA,EAAM,IAAI,mBAAmB;AAC3E;AAAA,IACF;AAEA,SAAK,SAAS,IAAIA,EAAM,MAAMA,CAAK,GAEnC,KAAK,uBAAuB;AAAA,EAC9B;AAAA,EAEA,YAAYkB,GAAMS,GAAS;AACzB,SAAK,SAAST,CAAI,IAAIS;AAAA,EACxB;AAAA,EAEA,aAAa;AACX,QAAG,CAAC,KAAK,QAAQ,QAAS;AAC1B,UAAM,EAAE,KAAAC,GAAK,QAAAC,EAAM,IAAK,KAAK,gBAAe,GACtC,EAAE,OAAAC,GAAO,SAAAC,MAAY,KAAK,aAC1B,EAAE,aAAaC,GAAoB,WAAWC,EAAgB,IAAK,KAAK,UACxEC,IAAcF,KAAA,OAAAA,IAAsB,SAAS,cAAc,KAAK,GAChEG,IAAYF,KAAA,OAAAA,IAAoB,SAAS,cAAc,KAAK;AAClE,IAAAC,EAAY,UAAU,IAAIb,EAAe,QAAQA,EAAe,WAAW,GAC3Ec,EAAU,UAAU,IAAId,EAAe,QAAQA,EAAe,SAAS;AACvE,UAAM,EAAE,KAAAX,GAAK,OAAAD,EAAK,IAAK,KAAK,QAAQ,eAE9B2B,IAAc,CAACR,GAAKS,MAAU;AAAA;AAAA;AAAA;AAAA,eAI3BT,CAAG;AAAA;AAAA;AAAA;AAAA,sBAIIS,CAAK;AAAA;AAGrB,IAAAH,EAAY,MAAM,UAAUE,EAAYR,IAAMG,GAAS,OAAO,GAC9DI,EAAU,MAAM,UAAUC,EAAYP,IAASC,GAAO,KAAK,GAE3DI,EAAY,cAAc,+BAA+BzB,CAAK,oBAC9D0B,EAAU,cAAc,6BAA6BzB,CAAG,oBAErD,CAACsB,KAAsB,CAACC,MACzB,SAAS,KAAK,OAAOC,CAAW,GAChC,SAAS,KAAK,OAAOC,CAAS,GAC9B,KAAK,YAAY,eAAeD,CAAW,GAC3C,KAAK,YAAY,aAAaC,CAAS;AAAA,EAE3C;AAAA,EAEA,qBAAqB;AACnB,UAAMG,IAAa,SAAS,cAAc,KAAK;AAC/C,IAAAA,EAAW,UAAU,IAAIjB,EAAe,SAAS,GACjDiB,EAAW,MAAM,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAQV,MAAM,KAAK,KAAK,SAAS,UAAU,UAAU,EACrD,QAAQ,CAAAC,MAAS;AACxB,MAAAD,EAAW,YAAYC,CAAK;AAAA,IAC9B,CAAC,GAED,KAAK,SAAS,UAAU,YAAYD,CAAU;AAAA,EAChD;AAAA,EAEA,kBAAkB;AAChB,UAAM,EAAE,WAAAvC,EAAS,IAAK,KAAK,UACrB,EAAE,gBAAAyC,GAAgB,YAAAC,MAAe,KAAK,SACtC,EAAE,OAAAX,EAAK,IAAK,KAAK,aACjBY,IAAgBF,IAAiB,MACjCG,IAAe,OAAO;AAE5B,IAAG,CAACH,KAAkBA,KAAkB,KACtC,QAAQ,KAAK,gEAAgE;AAG/E,UAAMI,IAAiBD,IAAeD;AAGtC,QADA,KAAK,QAAQ,YAAaE,IAAgBd,GACvCU,IAAiB,KAAKC,GAAY;AACnC,YAAMI,IAAYF,IAAeC;AACjC,MAAA7C,EAAU,MAAM,SAAS,GAAG8C,CAAS;AAAA,IACvC;AAEA,SAAK,iBAAiB,IAEtB,KAAK,WAAU,GACZ,KAAK,QAAQ,OAAK,KAAK,mBAAkB;AAAA,EAC9C;AAAA,EAEA,OAAOC,IAAQ,IAAO;AACpB,IAAG,KAAK,iBAAe,aAAa,KAAK,aAAa;AACtD,UAAMC,IAAK,OAAO;AAClB,KAAGA,MAAO,KAAK,kBAAkBD,OAC/B,KAAK,wBAAwB,MAC7B,KAAK,uBAAuB,MAC5B,KAAK,gBAAgB,WAAW,MAAM;AACpC,WAAK,iBAAiBC,GACtB,KAAK,QAAQ,KAAK,IAAI,EAAC;AAAA,IACzB,GAAG,GAAG;AAAA,EAEV;AAAA,EAEA,cAAcC,GAAO;AACnB,SAAK,SAASA,CAAK;AAAA,EACrB;AAAA,EAEA,cAAcA,GAAO;AACnB,SAAK,OAAM;AAAA,EACb;AAAA,EAEA,YAAW;AACT,UAAM,EAAE,UAAAC,GAAU,SAAAC,GAAS,YAAAC,EAAU,IAAK,KAAK;AAG/C,SAAK,sBAAsB,KAAK,cAAc,KAAK,IAAI,GACvD,KAAK,sBAAsB,KAAK,cAAc,KAAK,IAAI,GACvD,KAAK,iBAAiB,KAAK,SAAS,KAAK,IAAI,GAC7C,KAAK,gBAAgB,KAAK,QAAQ,KAAK,IAAI,GAC3C,KAAK,mBAAmB,KAAK,WAAW,KAAK,IAAI,GAEjD,OAAO,iBAAiB/B,EAAO,cAAc,KAAK,mBAAmB,GACrE,OAAO,iBAAiBA,EAAO,cAAc,KAAK,mBAAmB,GAErE,KAAK,SAAS,UAAU,iBAAiB6B,GAAU,KAAK,cAAc,GACtE,KAAK,SAAS,UAAU,iBAAiBC,GAAS,KAAK,aAAa,GACpE,KAAK,SAAS,UAAU,iBAAiBC,GAAY,KAAK,gBAAgB;AAAA,EAC5E;AAAA,EAEA,uBAAsB;AACpB,UAAM,EAAE,eAAAC,EAAa,IAAK,KAAK,SACzB,EAAE,OAAA3C,EAAK,IAAK2C,GACZ5B,IAAK,OAAO;AAElB,WAAGf,MAAU,QAAc,IACxBA,MAAU,WAAiBe,IAAK,IAChCf,MAAU,WAAiBe,IACvB;AAAA,EACT;AAAA,EAEA,0BAAyB;AACvB,UAAM,EAAE,eAAA4B,EAAa,IAAK,KAAK,SACzB,EAAE,KAAA1C,EAAG,IAAK0C,GACV5B,IAAK,OAAO;AAElB,WAAGd,MAAQ,QAAcc,IAAK,KAC3Bd,MAAQ,WAAkBc,IAAK,IAAK,KACX;AAAA,EAE9B;AAAA,EAEA,kBAAkB;AAChB,UAAM6B,IAAU,OAAO,WAAW,OAAO,aACnC,EAAE,WAAAtD,EAAS,IAAK,KAAK,UACrB,EAAE,SAAAgC,GAAS,OAAAD,MAAU,KAAK,aAC1B,EAAE,gBAAAU,GAAgB,YAAAC,MAAe,KAAK;AAG5C,IAAK,KAAK,0BACR,KAAK,wBAAwB;AAAA,MAC3B,IAAI,OAAO;AAAA,MACX,eAAgBA,IAAqC,IAAxBD,IAAiB;AAAA,MAC9C,mBAAmB,KAAK,qBAAoB;AAAA,MAC5C,sBAAsB,KAAK,wBAAuB;AAAA,IAC5D;AAGM,UAAM,EAAE,IAAAhB,GAAI,eAAAkB,GAAe,mBAAAY,GAAmB,sBAAAC,EAAoB,IAAK,KAAK,uBAEtEC,IAAgBzD,EAAU;AAChC,QAAI0D,IAAeD,EAAc,MAAMH,GACnCK,IAAkBF,EAAc,SAASH;AAC7C,IAAAK,KAAoBlC,IAAKkB;AAEzB,QAAIiB,IAAYN,IAAUC,GACtBM,IAAeP,IAAU7B,IAAK+B,GAE9BM,IAAmBJ,IAAe1B,IAAW4B,GAC7CG,IAAiBJ,IAAkB5B,IAAS8B;AAEhD,WAAO;AAAA,MACL,KAAKH;AAAA,MACL,QAAQD,EAAc;AAAA,MACtB,YAAYE,IAAkBD;AAAA,MAC9B,QAAQC;AAAA,MACR,SAASG;AAAA,MACT,OAAOC;AAAA,IACf;AAAA,EACI;AAAA,EAEA,SAASd,GAAO;AACd,QAAI,CAAC,KAAK,eAAgB;AAC1B,UAAM,EAAE,SAAAe,GAAS,OAAAC,EAAK,IAAK,KAAK,gBAAe;AAE/C,QAAIxD,IAAW;AAEf,QAAIuD,KAAW,KAAKC,KAAS,GAAG;AAC9B,YAAMC,IAAgB,KAAK,IAAIF,CAAO,IAAI,KAAK,IAAIC,CAAK,GAClDE,IAAkB,KAAK,IAAIH,CAAO;AACxC,MAAAvD,IAAWyD,IAAgB,IAAIC,IAAkBD,IAAgB;AAAA,IACnE,MAAO,CAAIF,IAAU,IACnBvD,IAAW,IACFwD,IAAQ,MACjBxD,IAAW;AAOb,QAJAA,IAAW,KAAK,IAAI,GAAG,KAAK,IAAI,GAAGA,CAAQ,CAAC,GAGvB,KAAK,IAAI,KAAK,WAAWA,CAAQ,IACnC,QAAS,KAAK,qBAAqB;AACpD;AAGF,UAAM,EAAE,WAAAT,EAAS,IAAK,KAAK,UACrB,EAAE,WAAAoE,EAAS,IAAK,KAAK,SACrBC,IAAkB,IAAI5D;AAE5B,SAAK,mBAAmB,KAAK,UAC7B,KAAK,WAAWA,GAChB,KAAK,kBAAkB4D;AAGvB,UAAMC,IAAc,KAAK;AACzB,IAAAA,EAAY,WAAW7D,GACvB6D,EAAY,YAAYF,GACxBE,EAAY,kBAAkBD,GAC9BC,EAAY,gBAAgB;AAG5B,UAAMC,IAAmB,OAClBD,EAAY,kBACfA,EAAY,gBAAgBtE,EAAU,0BAEjCsE,EAAY,gBAIf,EAAE,UAAApB,GAAU,SAAAC,GAAS,YAAAC,EAAU,IAAK,KAAK;AAW/C,IARI3C,IAAW,KAAK,CAAC,KAAK,eACxB,KAAK,aAAa,IAClB8D,KACA,KAAK,SAAS,UAAU,cAAc,IAAI,YAAYpB,GAAS;AAAA,MAC7D,QAAQ/B,EAAAlB,EAAA,IAAKoE,IAAL,EAAkB,eAAeA,EAAY,cAAa;AAAA,IAC5E,CAAS,CAAC,IAGE,GAAAN,KAAW,KAAKC,KAAS,KAAOD,IAAU,KAAKC,IAAQ,MAAO,KAAK,kBAAkB,QAI3F,KAAK,SAAS,UAAU,cAAc,IAAI,YAAYf,GAAU;AAAA,MAC9D,QAAQ9B,EAAAlB,EAAA,IAAKoE,IAAL,EAAkB,eAAeC,EAAgB,GAAI,aAAatB,EAAK;AAAA,IACvF,CAAO,CAAC,GAEExC,MAAa,KAAK,KAAK,mBAAmB,MAC5C8D,KACA,KAAK,SAAS,UAAU,cAAc,IAAI,YAAYnB,GAAY;AAAA,MAChE,QAAQhC,EAAAlB,EAAA,IAAKoE,IAAL,EAAkB,eAAeA,EAAY,cAAa;AAAA,IAC5E,CAAS,CAAC;AAAA,EAEN;AAAA,EAEA,SAASrB,GAAO;AACZ,UAAM,EAAE,UAAAxC,EAAQ,IAAKwC,EAAM;AAE3B,SAAK,gBAAgBxC,MAAa,IAAI,IAAKA,MAAa,IAAI,IAAI,IAE5DA,MAAa,MACf,KAAK,aAAa,KAIf,KAAK,yBACR,KAAK,uBAAuB;AAAA,MAC1B,QAAQ,OAAO,KAAK,KAAK,gBAAgB;AAAA,MACzC,UAAU,OAAO,KAAK,KAAK,QAAQ;AAAA,IAC/C;AAGQ,UAAM,EAAE,QAAQ+D,MAAqB,KAAK;AAG1C,IAAAA,EAAiB,QAAQ,CAAAjE,MAAa;AACpC,WAAK,iBAAiBA,CAAS,EAAE,KAAK,IAAI;AAAA,IAC5C,CAAC,GAED,KAAK,MAAM,YAAY,KAAK,MAAM,SAAS,KAAK,MAAM0C,CAAK;AAAA,EAC/D;AAAA,EAEA,QAAQA,GAAO;AACb,SAAK,MAAM,WAAW,KAAK,MAAM,QAAQ,KAAK,MAAMA,CAAK;AAAA,EAE3D;AAAA,EAEA,WAAWA,GAAO;AAChB,SAAK,MAAM,cAAc,KAAK,MAAM,WAAW,KAAK,MAAMA,CAAK;AAAA,EAEjE;AAAA,EAEA,mBAAmBvC,GAAOC,GAAKF,IAAW,KAAK,UAAS;AACtD,WAAO,KAAK,IAAI,GAAG,KAAK,IAAI,IAAIA,IAAWC,MAAUC,IAAMD,EAAM,CAAC;AAAA,EACpE;AAAA,EAEA,kBAAkBkB,GAAS6C,IAAU,IAAI;AACvC,QAAG,CAAC7C;AACF,qBAAQ,KAAK,wBAAwB,GAC9B;AAIT,UAAM;AAAA,MACF,MAAA8C,IAAO;AAAA;AAAA,MACP,QAAAC,IAAS;AAAA;AAAA,MACT,WAAAC,IAAY;AAAA;AAAA,MACZ,OAAAC,IAAQ;AAAA;AAAA,IAClB,IAAUJ,GAGEK,IAAW,GAAGlD,EAAQ,aAAa,SAAS,IAAI8C,CAAI,IAAIC,CAAM,IAAIC,CAAS;AAEjF,QAAIC,KAAS,KAAK,wBAAwB,KAAK,qBAAqBC,CAAQ;AACxE,aAAO,KAAK,qBAAqBA,CAAQ;AAG7C,QAAI;AACA,YAAM,EAAE,WAAA9E,EAAS,IAAK,KAAK,UACrB,EAAE,gBAAAyC,GAAgB,YAAAC,MAAe,KAAK,SAGtCe,IAAgBzD,EAAU,yBAC1B+E,IAAqB/E,EAAU,aAAa,GAC5C0D,IAAeD,EAAc,MAAM,OAAO,UAAUsB,GAEpDC,IAAcpD,EAAQ,yBACtBqD,IAAmBrD,EAAQ,aAAa,GACxCsD,IAAaF,EAAY,MAAM,OAAO,UAAUC,GAGhDxD,IAAK,OAAO,aACZkB,IAAiBD,IAAqC,IAAxBD,IAAiB,MAC/C0C,IAAuB1B,EAAc,SAAUhC,IAAKkB;AAG1D,UAAIyC,IAA0BF,IAAaxB,IAAeiB;AAG1D,cAAOD,GAAI;AAAA,QACP,KAAK;AAED,UAAAU,KAA2B;AAC3B;AAAA,QAEJ,KAAK;AAED,UAAAA,KAA2BJ,EAAY,SAAS;AAChD;AAAA,QAEJ,KAAK;AAED,UAAAI,KAA2BJ,EAAY;AACvC;AAAA,QAEJ,KAAK;AAED,UAAAI,KAA2BJ,EAAY,SAASJ;AAChD;AAAA,QAEJ;AACI,UAAAQ,KAA2B;AAAA,MAC7C;AAMU,YAAMC,IAHa,KAAK,IAAI,GAAG,KAAK,IAAI,GAAGD,IAA0BD,CAAoB,CAAC,IAGtD;AAGpC,aAAIN,MACK,KAAK,yBACN,KAAK,uBAAuB,KAEhC,KAAK,qBAAqBC,CAAQ,IAAIO,IAGnCA;AAAA,IAEX,SAASC,GAAO;AACZ,qBAAQ,KAAK,yCAAyCA,CAAK,GACpD;AAAA,IACX;AAAA,EACF;AAAA,EAEA,YAAY7E,GAAU8E,GAAU;AAC9B,SAAK,WAAW9E;AAChB,UAAM,EAAE,UAAAyC,EAAQ,IAAK,KAAK;AAE1B,SAAK,SAAS,UAAU,cAAc,IAAI,YAAYA,GAAU;AAAA,MAC9D,QAAQ;AAAA,QACN,WAAW,KAAK;AAAA,QAChB,UAAUzC;AAAA,MACpB;AAAA,IACA,CAAO,CAAC,GAEF,WAAW8E,GAAU,GAAG;AAAA,EAC1B;AAAA,EAEA,UAAU;AACR,IAAI,KAAK,uBACL,OAAO,oBAAoBlE,EAAO,cAAc,KAAK,mBAAmB,GAExE,KAAK,uBACL,OAAO,oBAAoBA,EAAO,cAAc,KAAK,mBAAmB;AAG5E,UAAM,EAAE,UAAA6B,GAAU,SAAAC,GAAS,YAAAC,EAAU,IAAK,KAAK;AAC/C,IAAI,KAAK,kBACL,KAAK,SAAS,UAAU,oBAAoBF,GAAU,KAAK,cAAc,GAEzE,KAAK,iBACL,KAAK,SAAS,UAAU,oBAAoBC,GAAS,KAAK,aAAa,GAEvE,KAAK,oBACL,KAAK,SAAS,UAAU,oBAAoBC,GAAY,KAAK,gBAAgB,GAIjF,KAAK,sBAAsB,MAC3B,KAAK,sBAAsB,MAC3B,KAAK,iBAAiB,MACtB,KAAK,gBAAgB,MACrB,KAAK,mBAAmB,MAExB,KAAK,WAAW,GAChB,KAAK,mBAAmB,GACxB,KAAK,gBAAgB,IACrB,KAAK,wBAAwB,MAC7B,KAAK,uBAAuB,MAC5B,KAAK,iBAAiB;AAAA,EACxB;AAAA,EAEA,UAAS;AACP,SAAK,QAAO,GACZ,KAAK,KAAI;AAAA,EACX;AACJ;AAEA,MAAMoC,EAAI;AAAA,EACR,cAAe;AACb,SAAK,YAAY,IAEjB,KAAK,UAAS;AAAA,EAChB;AAAA,EAEA,gCAAgC;AAC5B,QAAIC,IAAU,IACVC,IAAW;AAEf,WAAO,CAACzC,MAAU;AAChB,YAAM0C,IAAM,YAAY;AAExB,MAAIA,IAAMD,IAAW,SAEhBD,MACHC,IAAWC,GAEX,sBAAsB,MAAM;AAC1B,cAAMC,IAAc,IAAI,YAAYvE,EAAO,cAAc,EAAE,QAAQ,EAAE,eAAe4B,EAAK,EAAE,CAAE;AAC7F,eAAO,cAAc2C,CAAW,GAChCH,IAAU;AAAA,MACZ,CAAC,GAEDA,IAAU;AAAA,IAEd;AAAA,EACJ;AAAA,EAEA,8BAA8BxC,GAAO;AACjC,QAAI4C;AAEJ,WAAO,CAAC5C,MAAU;AAChB,mBAAa4C,CAAa,GAC1BA,IAAgB,WAAW,MAAM;AAC/B,cAAMD,IAAc,IAAI,YAAYvE,EAAO,cAAc,EAAE,QAAQ,EAAE,eAAe4B,EAAK,EAAE,CAAE;AAC7F,eAAO,cAAc2C,CAAW;AAAA,MAClC,GAAG,GAAG;AAAA,IACR;AAAA,EACJ;AAAA,EAEA,YAAW;AACT,WAAO,iBAAiB,UAAU,KAAK,8BAA6B,GAAI,EAAE,SAAS,GAAI,CAAE,GACzF,OAAO,iBAAiB,UAAU,KAAK,8BAA6B,CAAE;AAAA,EACxE;AAAA,EAEA,gBAAgB5F,GAAWC,IAAQ,IAAI;AACrC,QAAG,CAACD,GAAW;AACb,cAAQ,MAAM,8CAA8C;AAC5D;AAAA,IACF;AAEA,QAAImB,IAAOlB,EAAM;AAKjB,QAJKkB,MACHA,IAAOnB,EAAU,aAAa,WAAW,KAAK,YAAY,OAAO,KAAK,KAAK,SAAS,EAAE,SAAS,CAAC,KAG/F,KAAK,UAAUmB,CAAI,GAAG;AACvB,cAAQ,KAAK,uBAAuBA,CAAI,wEAAwE;AAChH;AAAA,IACF;AAEA,UAAM2E,IAAW,IAAIvE,EAAavB,GAAWC,CAAK;AAClD,gBAAK,YAAY6F,GAAU3E,CAAI,GAExB,KAAK,UAAUA,CAAI;AAAA,EAC5B;AAAA,EAEA,YAAY2E,GAAU3E,GAAM;AAC1B,SAAK,UAAUA,CAAI,IAAI2E;AAAA,EACzB;AAAA,EAEA,YAAY3E,GAAM;AAChB,WAAO,KAAK,UAAUA,CAAI;AAAA,EAC5B;AACF;AAeI,OAAO,UAAW,gBACpB,OAAO,MAAMqE;"}