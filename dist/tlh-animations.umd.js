(function(i,o){typeof exports=="object"&&typeof module!="undefined"?o(exports):typeof define=="function"&&define.amd?define(["exports"],o):(i=typeof globalThis!="undefined"?globalThis:i||self,o(i.TLH={}))})(this,(function(i){"use strict";var H=Object.defineProperty,V=Object.defineProperties;var $=Object.getOwnPropertyDescriptors;var M=Object.getOwnPropertySymbols;var x=Object.prototype.hasOwnProperty,I=Object.prototype.propertyIsEnumerable;var z=(i,o,h)=>o in i?H(i,o,{enumerable:!0,configurable:!0,writable:!0,value:h}):i[o]=h,w=(i,o)=>{for(var h in o||(o={}))x.call(o,h)&&z(i,h,o[h]);if(M)for(var h of M(o))I.call(o,h)&&z(i,h,o[h]);return i},_=(i,o)=>V(i,$(o));var A=(i,o,h)=>z(i,typeof o!="symbol"?o+"":o,h);class o{constructor(t,e={}){this.elements={container:t},this.customAnimations=e.customAnimations||{},this.scrollCords={startAt:0,endAt:0},this._cachedVWValue=window.innerWidth,this.progress=0,this.previousProgress=0,this.progressEnded=!1,this.interfaceReady=!1,this.hasStarted=!1,this._lastScrollTime=0,this.timeline={},this.options=w(w({start:0,end:0,markers:!1,pin:!1,detectionMode:{start:"top",end:"bottom"},scrollDistance:0,fullscreen:!0},this.getDataOptions()),e.options),this._eventDetailPool={container:t,progress:0,containerRect:null,scrollTop:0,progressReverse:0}}}class h{}A(h,"easing",{linear:t=>t,easeIn:t=>t*t,easeOut:t=>t*(2-t),easeInOut:t=>t<.5?2*t*t:-1+(4-2*t)*t,bounce:t=>t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375}),A(h,"selector",t=>typeof t=="string"?document.querySelectorAll(t):[t]);class U{constructor(t,e){if(this.name=t,this.props=e,this.container=e.container||null,this.start=e.start?e.start:0,this.end=e.end?e.end:100,this.duration=e.duration?e.duration:1,this.normalizedProgress=0,this.hasStarted=!1,this.progressEnded=!1,this.progress=0,!this.container){console.error("Container is required for animation:",t);return}return this.container.addEventListener(this.props.events.onUpdate,n=>{this.updateTimeline(n.detail.progress)}),this}onUpdate(){this.progress===0&&(this.hasStarted=!1),this.progressEnded=this.progress===1?1:this.progress===0?0:!1,this.props.onUpdate&&this.props.onUpdate.bind(this)()}onStart(){this.hasStarted=!0,this.props.onStart&&this.props.onStart.bind(this)()}onComplete(){this.props.onComplete&&this.props.onComplete.bind(this)()}updateTimeline(t){const{start:e,end:n,duration:s}=this;this._cachedUnits||(this._cachedUnits={startUnit:e*.01,endUnit:n*.01});const{startUnit:c,endUnit:d}=this._cachedUnits,a=this.props.normalizedProgress(c,d,t);let r;s!==1?r=Math.pow(a,s):r=a,r=Math.max(0,Math.min(1,r)),this.progress=a,this.normalizedProgress=r,this.progress>0&&!this.hasStarted&&this.onStart(),this.onUpdate(),t===1&&this.onComplete()}}class P{constructor(t){this.parent=t,this.elements=t.elements,this.customEvents=t.customEvents,this.normalizedProgress=t.normalizedProgress}add(t,e){if(!t){console.error("Animation name is required");return}if(!e){console.error("Animation props are required");return}return new U(t,_(w({},e),{normalizedProgress:this.normalizedProgress,container:this.elements.container,events:this.customEvents}))}}const u={onUpdate:"tlh-animate-update",onStart:"tlh-animate-start",onComplete:"tlh-animate-complete",globalScroll:"tlh-global-scroll",globalResize:"tlh-global-resize"},E={marker:"tlh-scroll-marker",markerStart:"tlh-scroll-marker-start",markerEnd:"tlh-scroll-marker-end",pinSpacer:"tlh-pin-section",pinInner:"tlh-pin-inner"};class k extends o{constructor(t,e={}){super(t,e),this.props=e,this.customEvents={onUpdate:u.onUpdate,onStart:u.onStart,onComplete:u.onComplete},this.timeline=new P(this),this.init()}getDataOptions(){return this.elements.container.dataset}init(){this.setElements("container",this.elements.container),this.props.onMounted&&this.props.onMounted.call(this),this.setScrollCords(),this.createInterface(),this.setEvents()}setScrollCords(){const{end:t,start:e}=this.options,n=window.innerHeight,s=n*(e*.01),c=n*(t*.01);this.scrollCords.startAt=s,this.scrollCords.endAt=c}addToTimeline(t){if(!t.name){console.warn("You must provide a name for the timeline animation.");return}if(this.timeline[t.name]){console.warn(`Timeline animation with name "${t.name}" already exists.`);return}this.timeline.add(t.name,t),this._cachedAnimationKeys=null}setElements(t,e){this.elements[t]=e}addMarkers(){if(!this.options.markers)return;const{top:t,bottom:e}=this.getElementCords(),{endAt:n,startAt:s}=this.scrollCords,{startMarker:c,endMarker:d}=this.elements,a=c!=null?c:document.createElement("div"),r=d!=null?d:document.createElement("div");a.classList.add(E.marker,E.markerStart),r.classList.add(E.marker,E.markerEnd);const{end:l,start:f}=this.options.detectionMode,m=(g,p)=>`
        position: absolute;
        left: 0;
        right: 0;
        top: ${g}px;
        width: 100%;
        height: 2px;
        z-index: 9999;
        background: ${p};
      `;a.style.cssText=m(t-s,"green"),r.style.cssText=m(e+n,"red"),a.textContent=`Start - once this touch the ${f} of the viewport`,r.textContent=`End - once this touch the ${l} of the viewport`,!c&&!d&&(document.body.append(a),document.body.append(r),this.setElements("startMarker",a),this.setElements("endMarker",r))}createPinInterface(){const t=document.createElement("div");t.classList.add(E.pinSpacer),t.style.cssText=`
        position: sticky;
        top: 0;
        height: 100vh;
        width: 100%;
        pointer-events: none;
      `,Array.from(this.elements.container.childNodes).forEach(n=>{t.appendChild(n)}),this.elements.container.appendChild(t)}createInterface(){const{container:t}=this.elements,{scrollDistance:e,fullscreen:n}=this.options,{endAt:s}=this.scrollCords,c=e*.01,d=window.innerHeight;!e&&e!=0&&console.warn("scrollDistance must be defined on element or animation options");const a=d*c;if(this.options.scrollTop=a+s,e>0&&n){const r=d+a;t.style.height=`${r}px`}this.interfaceReady=!0,this.addMarkers(),this.options.pin&&this.createPinInterface()}resize(t=!1){this.resizeTimeout&&clearTimeout(this.resizeTimeout);const e=window.innerWidth;(e!==this._cachedVWValue||t)&&(this._cachedViewportValues=null,this._cachedAnimationKeys=null,this.resizeTimeout=setTimeout(()=>{this._cachedVWValue=e,this.rebuild.bind(this)()},200))}scrollControl(t){this.onScroll(t)}resizeControl(t){this.resize()}setEvents(){const{onUpdate:t,onStart:e,onComplete:n}=this.customEvents;this._boundScrollControl=this.scrollControl.bind(this),this._boundResizeControl=this.resizeControl.bind(this),this._boundOnUpdate=this.onUpdate.bind(this),this._boundOnStart=this.onStart.bind(this),this._boundOnComplete=this.onComplete.bind(this),window.addEventListener(u.globalScroll,this._boundScrollControl),window.addEventListener(u.globalResize,this._boundResizeControl),this.elements.container.addEventListener(t,this._boundOnUpdate),this.elements.container.addEventListener(e,this._boundOnStart),this.elements.container.addEventListener(n,this._boundOnComplete)}getTopDetectionRange(){const{detectionMode:t}=this.options,{start:e}=t,n=window.innerHeight;return e==="top"?0:e==="center"?n/2:e==="bottom"?n:0}getBottomDetectionRange(){const{detectionMode:t}=this.options,{end:e}=t,n=window.innerHeight;return e==="top"?n*-1:e==="center"?n/2*-1:0}getElementCords(){const t=window.scrollY||window.pageYOffset,{container:e}=this.elements,{startAt:n,endAt:s}=this.scrollCords,{scrollDistance:c,fullscreen:d}=this.options;this._cachedViewportValues||(this._cachedViewportValues={vh:window.innerHeight,scaleDistance:d?0:c*.01,topDetectionRange:this.getTopDetectionRange(),bottomDetectionRange:this.getBottomDetectionRange()});const{vh:a,scaleDistance:r,topDetectionRange:l,bottomDetectionRange:f}=this._cachedViewportValues,m=e.getBoundingClientRect();let g=m.top+t,p=m.bottom+t;p+=a*r;let v=t+l,S=t+a+f,R=g-n-v,y=p+s-S;return{top:g,height:m.height,totalSpace:p-g,bottom:p,toStart:R,toEnd:y}}onScroll(t){if(!this.interfaceReady)return;const{toStart:e,toEnd:n}=this.getElementCords();let s=0;if(e<=0&&n>=0){const v=Math.abs(e)+Math.abs(n),S=Math.abs(e);s=v>0?S/v:0}else e>0?s=0:n<0&&(s=1);if(s=Math.max(0,Math.min(1,s)),Math.abs(this.progress-s)<.001&&this.previousProgress!==void 0)return;const{container:d}=this.elements,{scrollTop:a}=this.options,r=1-s;this.previousProgress=this.progress,this.progress=s,this.progressReverse=r;const l=this._eventDetailPool;l.progress=s,l.scrollTop=a,l.progressReverse=r,l.containerRect=null;const f=()=>(l.containerRect||(l.containerRect=d.getBoundingClientRect()),l.containerRect),{onUpdate:m,onStart:g,onComplete:p}=this.customEvents;s>0&&!this.hasStarted&&(this.hasStarted=!0,f(),this.elements.container.dispatchEvent(new CustomEvent(g,{detail:_(w({},l),{containerRect:l.containerRect})}))),!((e>=0&&n>=0||e<0&&n<0)&&this.progressEnded!==!1)&&(this.elements.container.dispatchEvent(new CustomEvent(m,{detail:_(w({},l),{containerRect:f(),scrollEvent:t})})),s===1&&this.previousProgress<1&&(f(),this.elements.container.dispatchEvent(new CustomEvent(p,{detail:_(w({},l),{containerRect:l.containerRect})}))))}onUpdate(t){const{progress:e}=t.detail;this.progressEnded=e===1?1:e===0?0:!1,e===0&&(this.hasStarted=!1),this._cachedAnimationKeys||(this._cachedAnimationKeys={custom:Object.keys(this.customAnimations),timeline:Object.keys(this.timeline)});const{custom:n}=this._cachedAnimationKeys;n.forEach(s=>{this.customAnimations[s].call(this)}),this.props.onUpdate&&this.props.onUpdate.call(this,t)}onStart(t){this.props.onStart&&this.props.onStart.call(this,t)}onComplete(t){this.props.onComplete&&this.props.onComplete.call(this,t)}normalizedProgress(t,e,n=this.progress){return Math.max(0,Math.min(1,(n-t)/(e-t)))}getPercentElement(t,e={}){if(!t)return console.warn("Element is not defined"),0;const{mode:n="start",offset:s=0,threshold:c=.5,cache:d=!0}=e,a=`${t.className||"element"}-${n}-${s}-${c}`;if(d&&this._elementPercentCache&&this._elementPercentCache[a])return this._elementPercentCache[a];try{const{container:r}=this.elements,{scrollDistance:l,fullscreen:f}=this.options,m=r.getBoundingClientRect(),g=r.scrollTop||0,p=m.top+window.scrollY-g,v=t.getBoundingClientRect(),S=t.scrollTop||0,R=v.top+window.scrollY-S,y=window.innerHeight,L=f?0:l*.01,D=m.height+y*L;let b=R-p+s;switch(n){case"start":b+=0;break;case"center":b+=v.height/2;break;case"end":b+=v.height;break;case"visible":b+=v.height*c;break;default:b+=0}const O=Math.max(0,Math.min(1,b/D))*100;return d&&(this._elementPercentCache||(this._elementPercentCache={}),this._elementPercentCache[a]=O),O}catch(r){return console.warn("Error calculating element percentage:",r),0}}setProgress(t,e){this.progress=t;const{onUpdate:n}=this.customEvents;this.elements.container.dispatchEvent(new CustomEvent(n,{detail:{container:this.container,progress:t}})),setTimeout(e,200)}destroy(){this._boundScrollControl&&window.removeEventListener(u.globalScroll,this._boundScrollControl),this._boundResizeControl&&window.removeEventListener(u.globalResize,this._boundResizeControl);const{onUpdate:t,onStart:e,onComplete:n}=this.customEvents;this._boundOnUpdate&&this.elements.container.removeEventListener(t,this._boundOnUpdate),this._boundOnStart&&this.elements.container.removeEventListener(e,this._boundOnStart),this._boundOnComplete&&this.elements.container.removeEventListener(n,this._boundOnComplete),this._boundScrollControl=null,this._boundResizeControl=null,this._boundOnUpdate=null,this._boundOnStart=null,this._boundOnComplete=null,this.progress=0,this.previousProgress=0,this.progressEnded=!1,this._cachedViewportValues=null,this._cachedAnimationKeys=null,this.interfaceReady=!1}rebuild(){this.destroy(),this.init()}}class T{constructor(){this.instances={},this.setEvents()}_createOptimizedScrollHandler(){let t=!1,e=0;return n=>{const s=performance.now();s-e<16.67||t||(e=s,requestAnimationFrame(()=>{const c=new CustomEvent(u.globalScroll,{detail:{originalEvent:n}});window.dispatchEvent(c),t=!1}),t=!0)}}_createOptimizedResizeHandler(t){let e;return n=>{clearTimeout(e),e=setTimeout(()=>{const s=new CustomEvent(u.globalResize,{detail:{originalEvent:n}});window.dispatchEvent(s)},100)}}setEvents(){window.addEventListener("scroll",this._createOptimizedScrollHandler(),{passive:!0}),window.addEventListener("resize",this._createOptimizedResizeHandler())}createAnimation(t,e={}){if(!t){console.error("No container element provided for animation.");return}let n=e.name;if(n||(n=t.getAttribute("data-name")||`instance-${Object.keys(this.instances).length+1}`),this.instances[n]){console.warn(`Instance with name "${n}" already exists. Skipping creation. Please set a valid name on props.`);return}const s=new k(t,e);return this.addInstance(s,n),this.instances[n]}addInstance(t,e){this.instances[e]=t}getInstance(t){return this.instances[t]}}typeof window!="undefined"&&(window.TLH=T),i.AnimationConstructor=o,i.ELEMENTS_CLASS=E,i.EVENTS=u,i.Helpers=h,i.TLH=T,i.TLHAnimation=k,i.TimeLine=P,i.default=T,Object.defineProperties(i,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
//# sourceMappingURL=tlh-animations.umd.js.map
