(function(o,a){typeof exports=="object"&&typeof module!="undefined"?a(exports):typeof define=="function"&&define.amd?define(["exports"],a):(o=typeof globalThis!="undefined"?globalThis:o||self,a(o.TLH={}))})(this,(function(o){"use strict";var H=Object.defineProperty,V=Object.defineProperties;var $=Object.getOwnPropertyDescriptors;var M=Object.getOwnPropertySymbols;var x=Object.prototype.hasOwnProperty,I=Object.prototype.propertyIsEnumerable;var A=(o,a,d)=>a in o?H(o,a,{enumerable:!0,configurable:!0,writable:!0,value:d}):o[a]=d,v=(o,a)=>{for(var d in a||(a={}))x.call(a,d)&&A(o,d,a[d]);if(M)for(var d of M(a))I.call(a,d)&&A(o,d,a[d]);return o},_=(o,a)=>V(o,$(a));var z=(o,a,d)=>A(o,typeof a!="symbol"?a+"":a,d);class a{constructor(t,e={}){this.elements={container:t},this.customAnimations=e.customAnimations||{},this.scrollCords={startAt:0,endAt:0},this._cachedVWValue=window.innerWidth,this.progress=0,this.previousProgress=0,this.progressEnded=!1,this.interfaceReady=!1,this.hasStarted=!1,this._lastScrollTime=0,this.timeline={},this.options=v(v({start:0,end:0,markers:!1,pin:!1,detectionMode:{start:"top",end:"bottom"},scrollDistance:0,fullscreen:!0},this.getDataOptions()),e.options),this._eventDetailPool={container:t,progress:0,containerRect:null,scrollTop:0,progressReverse:0}}}class d{constructor(){z(this,"easing",{linear:t=>t,easeIn:t=>t*t,easeOut:t=>t*(2-t),easeInOut:t=>t<.5?2*t*t:-1+(4-2*t)*t,bounce:t=>t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375});z(this,"selector",t=>typeof t=="string"?document.querySelectorAll(t):[t])}getElementPosition(t){typeof t=="string"&&(t=document.querySelector(t));const e=t.getBoundingClientRect(),n=window.pageYOffset||document.documentElement.scrollTop,s=window.pageXOffset||document.documentElement.scrollLeft;return{top:e.top+n,left:e.left+s}}scrollTo(t,e=500,n="linear"){const s=window.scrollY||window.pageYOffset,c=typeof t=="number"?t:this.getElementPosition(t).top,h=c-s;let r=null;if(e<=0){window.scrollTo(0,c);return}const i=l=>{r===null&&(r=l);const u=l-r,m=Math.min(u/e,1),p=this.easing[n](m)*h+s;window.scrollTo(0,p),m<1&&requestAnimationFrame(i)};requestAnimationFrame(i)}}class L{constructor(t,e){if(this.name=t,this.props=e,this.container=e.container||null,this.start=e.start?e.start:0,this.end=e.end?e.end:100,this.duration=e.duration?e.duration:1,this.normalizedProgress=0,this.hasStarted=!1,this.progressEnded=!1,this.progress=0,!this.container){console.error("Container is required for animation:",t);return}return this.container.addEventListener(this.props.events.onUpdate,n=>{this.updateTimeline(n.detail.progress)}),this}onUpdate(){this.progress===0&&(this.hasStarted=!1),this.progressEnded=this.progress===1?1:this.progress===0?0:!1,this.props.onUpdate&&this.props.onUpdate.bind(this)()}onStart(){this.hasStarted=!0,this.props.onStart&&this.props.onStart.bind(this)()}onComplete(){this.props.onComplete&&this.props.onComplete.bind(this)()}updateTimeline(t){const{start:e,end:n,duration:s}=this;this._cachedUnits||(this._cachedUnits={startUnit:e*.01,endUnit:n*.01});const{startUnit:c,endUnit:h}=this._cachedUnits,r=this.props.normalizedProgress(c,h,t);let i;s!==1?i=Math.pow(r,s):i=r,i=Math.max(0,Math.min(1,i)),this.progress=r,this.normalizedProgress=i,this.progress>0&&!this.hasStarted&&this.onStart(),this.onUpdate(),t===1&&this.onComplete()}}class P{constructor(t){this.parent=t,this.elements=t.elements,this.customEvents=t.customEvents,this.normalizedProgress=t.normalizedProgress}add(t,e){if(!t){console.error("Animation name is required");return}if(!e){console.error("Animation props are required");return}return new L(t,_(v({},e),{normalizedProgress:this.normalizedProgress,container:this.elements.container,events:this.customEvents}))}}const f={onUpdate:"tlh-animate-update",onStart:"tlh-animate-start",onComplete:"tlh-animate-complete",globalScroll:"tlh-global-scroll",globalResize:"tlh-global-resize"},E={marker:"tlh-scroll-marker",markerStart:"tlh-scroll-marker-start",markerEnd:"tlh-scroll-marker-end",pinSpacer:"tlh-pin-section",pinInner:"tlh-pin-inner"};class O extends a{constructor(t,e={}){super(t,e),this.props=e,this.customEvents={onUpdate:f.onUpdate,onStart:f.onStart,onComplete:f.onComplete},this.timeline=new P(this),this.init()}getDataOptions(){return this.elements.container.dataset}init(){this.setElements("container",this.elements.container),this.props.onMounted&&this.props.onMounted.call(this),this.setScrollCords(),this.createInterface(),this.setEvents()}setScrollCords(){const{end:t,start:e}=this.options,n=window.innerHeight,s=n*(e*.01),c=n*(t*.01);this.scrollCords.startAt=s,this.scrollCords.endAt=c}addToTimeline(t){if(!t.name){console.warn("You must provide a name for the timeline animation.");return}if(this.timeline[t.name]){console.warn(`Timeline animation with name "${t.name}" already exists.`);return}this.timeline.add(t.name,t),this._cachedAnimationKeys=null}setElements(t,e){this.elements[t]=e}addMarkers(){if(!this.options.markers)return;const{top:t,bottom:e}=this.getElementCords(),{endAt:n,startAt:s}=this.scrollCords,{startMarker:c,endMarker:h}=this.elements,r=c!=null?c:document.createElement("div"),i=h!=null?h:document.createElement("div");r.classList.add(E.marker,E.markerStart),i.classList.add(E.marker,E.markerEnd);const{end:l,start:u}=this.options.detectionMode,m=(p,g)=>`
        position: absolute;
        left: 0;
        right: 0;
        top: ${p}px;
        width: 100%;
        height: 2px;
        z-index: 9999;
        background: ${g};
      `;r.style.cssText=m(t-s,"green"),i.style.cssText=m(e+n,"red"),r.textContent=`Start - once this touch the ${u} of the viewport`,i.textContent=`End - once this touch the ${l} of the viewport`,!c&&!h&&(document.body.append(r),document.body.append(i),this.setElements("startMarker",r),this.setElements("endMarker",i))}createPinInterface(){const t=document.createElement("div");t.classList.add(E.pinSpacer),t.style.cssText=`
        position: sticky;
        top: 0;
        height: 100vh;
        width: 100%;
        pointer-events: none;
      `,Array.from(this.elements.container.childNodes).forEach(n=>{t.appendChild(n)}),this.elements.container.appendChild(t)}createInterface(){const{container:t}=this.elements,{scrollDistance:e,fullscreen:n}=this.options,{endAt:s}=this.scrollCords,c=e*.01,h=window.innerHeight;!e&&e!=0&&console.warn("scrollDistance must be defined on element or animation options");const r=h*c;if(this.options.scrollTop=r+s,e>0&&n){const i=h+r;t.style.height=`${i}px`}this.interfaceReady=!0,this.addMarkers(),this.options.pin&&this.createPinInterface()}resize(t=!1){this.resizeTimeout&&clearTimeout(this.resizeTimeout);const e=window.innerWidth;(e!==this._cachedVWValue||t)&&(this._cachedViewportValues=null,this._cachedAnimationKeys=null,this.resizeTimeout=setTimeout(()=>{this._cachedVWValue=e,this.rebuild.bind(this)()},200))}scrollControl(t){this.onScroll(t)}resizeControl(t){this.resize()}setEvents(){const{onUpdate:t,onStart:e,onComplete:n}=this.customEvents;this._boundScrollControl=this.scrollControl.bind(this),this._boundResizeControl=this.resizeControl.bind(this),this._boundOnUpdate=this.onUpdate.bind(this),this._boundOnStart=this.onStart.bind(this),this._boundOnComplete=this.onComplete.bind(this),window.addEventListener(f.globalScroll,this._boundScrollControl),window.addEventListener(f.globalResize,this._boundResizeControl),this.elements.container.addEventListener(t,this._boundOnUpdate),this.elements.container.addEventListener(e,this._boundOnStart),this.elements.container.addEventListener(n,this._boundOnComplete)}getTopDetectionRange(){const{detectionMode:t}=this.options,{start:e}=t,n=window.innerHeight;return e==="top"?0:e==="center"?n/2:e==="bottom"?n:0}getBottomDetectionRange(){const{detectionMode:t}=this.options,{end:e}=t,n=window.innerHeight;return e==="top"?n*-1:e==="center"?n/2*-1:0}getElementCords(){const t=window.scrollY||window.pageYOffset,{container:e}=this.elements,{startAt:n,endAt:s}=this.scrollCords,{scrollDistance:c,fullscreen:h}=this.options;this._cachedViewportValues||(this._cachedViewportValues={vh:window.innerHeight,scaleDistance:h?0:c*.01,topDetectionRange:this.getTopDetectionRange(),bottomDetectionRange:this.getBottomDetectionRange()});const{vh:r,scaleDistance:i,topDetectionRange:l,bottomDetectionRange:u}=this._cachedViewportValues,m=e.getBoundingClientRect();let p=m.top+t,g=m.bottom+t;g+=r*i;let w=t+l,S=t+r+u,R=p-n-w,y=g+s-S;return{top:p,height:m.height,totalSpace:g-p,bottom:g,toStart:R,toEnd:y}}onScroll(t){if(!this.interfaceReady)return;const{toStart:e,toEnd:n}=this.getElementCords();let s=0;if(e<=0&&n>=0){const w=Math.abs(e)+Math.abs(n),S=Math.abs(e);s=w>0?S/w:0}else e>0?s=0:n<0&&(s=1);if(s=Math.max(0,Math.min(1,s)),Math.abs(this.progress-s)<.001&&this.previousProgress!==void 0)return;const{container:h}=this.elements,{scrollTop:r}=this.options,i=1-s;this.previousProgress=this.progress,this.progress=s,this.progressReverse=i;const l=this._eventDetailPool;l.progress=s,l.scrollTop=r,l.progressReverse=i,l.containerRect=null;const u=()=>(l.containerRect||(l.containerRect=h.getBoundingClientRect()),l.containerRect),{onUpdate:m,onStart:p,onComplete:g}=this.customEvents;s>0&&!this.hasStarted&&(this.hasStarted=!0,u(),this.elements.container.dispatchEvent(new CustomEvent(p,{detail:_(v({},l),{containerRect:l.containerRect})}))),!((e>=0&&n>=0||e<0&&n<0)&&this.progressEnded!==!1)&&(this.elements.container.dispatchEvent(new CustomEvent(m,{detail:_(v({},l),{containerRect:u(),scrollEvent:t})})),s===1&&this.previousProgress<1&&(u(),this.elements.container.dispatchEvent(new CustomEvent(g,{detail:_(v({},l),{containerRect:l.containerRect})}))))}onUpdate(t){const{progress:e}=t.detail;this.progressEnded=e===1?1:e===0?0:!1,e===0&&(this.hasStarted=!1),this._cachedAnimationKeys||(this._cachedAnimationKeys={custom:Object.keys(this.customAnimations),timeline:Object.keys(this.timeline)});const{custom:n}=this._cachedAnimationKeys;n.forEach(s=>{this.customAnimations[s].call(this)}),this.props.onUpdate&&this.props.onUpdate.call(this,t)}onStart(t){this.props.onStart&&this.props.onStart.call(this,t)}onComplete(t){this.props.onComplete&&this.props.onComplete.call(this,t)}normalizedProgress(t,e,n=this.progress){return Math.max(0,Math.min(1,(n-t)/(e-t)))}getPercentElement(t,e={}){if(!t)return console.warn("Element is not defined"),0;const{mode:n="start",offset:s=0,threshold:c=.5,cache:h=!0}=e,r=`${t.className||"element"}-${n}-${s}-${c}`;if(h&&this._elementPercentCache&&this._elementPercentCache[r])return this._elementPercentCache[r];try{const{container:i}=this.elements,{scrollDistance:l,fullscreen:u}=this.options,m=i.getBoundingClientRect(),p=i.scrollTop||0,g=m.top+window.scrollY-p,w=t.getBoundingClientRect(),S=t.scrollTop||0,R=w.top+window.scrollY-S,y=window.innerHeight,U=u?0:l*.01,D=m.height+y*U;let b=R-g+s;switch(n){case"start":b+=0;break;case"center":b+=w.height/2;break;case"end":b+=w.height;break;case"visible":b+=w.height*c;break;default:b+=0}const k=Math.max(0,Math.min(1,b/D))*100;return h&&(this._elementPercentCache||(this._elementPercentCache={}),this._elementPercentCache[r]=k),k}catch(i){return console.warn("Error calculating element percentage:",i),0}}setProgress(t,e){this.progress=t;const{onUpdate:n}=this.customEvents;this.elements.container.dispatchEvent(new CustomEvent(n,{detail:{container:this.container,progress:t}})),setTimeout(e,200)}destroy(){this._boundScrollControl&&window.removeEventListener(f.globalScroll,this._boundScrollControl),this._boundResizeControl&&window.removeEventListener(f.globalResize,this._boundResizeControl);const{onUpdate:t,onStart:e,onComplete:n}=this.customEvents;this._boundOnUpdate&&this.elements.container.removeEventListener(t,this._boundOnUpdate),this._boundOnStart&&this.elements.container.removeEventListener(e,this._boundOnStart),this._boundOnComplete&&this.elements.container.removeEventListener(n,this._boundOnComplete),this._boundScrollControl=null,this._boundResizeControl=null,this._boundOnUpdate=null,this._boundOnStart=null,this._boundOnComplete=null,this.progress=0,this.previousProgress=0,this.progressEnded=!1,this._cachedViewportValues=null,this._cachedAnimationKeys=null,this.interfaceReady=!1}rebuild(){this.destroy(),this.init()}}class T{constructor(){this.instances={},this.helpers=new d,this.setEvents()}_createOptimizedScrollHandler(){let t=!1,e=0;return n=>{const s=performance.now();s-e<16.67||t||(e=s,requestAnimationFrame(()=>{const c=new CustomEvent(f.globalScroll,{detail:{originalEvent:n}});window.dispatchEvent(c),t=!1}),t=!0)}}_createOptimizedResizeHandler(t){let e;return n=>{clearTimeout(e),e=setTimeout(()=>{const s=new CustomEvent(f.globalResize,{detail:{originalEvent:n}});window.dispatchEvent(s)},100)}}setEvents(){window.addEventListener("scroll",this._createOptimizedScrollHandler(),{passive:!0}),window.addEventListener("resize",this._createOptimizedResizeHandler())}createAnimation(t,e={}){if(!t){console.error("No container element provided for animation.");return}let n=e.name;if(n||(n=t.getAttribute("data-name")||`instance-${Object.keys(this.instances).length+1}`),this.instances[n]){console.warn(`Instance with name "${n}" already exists. Skipping creation. Please set a valid name on props.`);return}e.helpers=this.helpers;const s=new O(t,e);return this.addInstance(s,n),this.instances[n]}addInstance(t,e){this.instances[e]=t}getInstance(t){return this.instances[t]}}typeof window!="undefined"&&(window.TLH=T),o.AnimationConstructor=a,o.ELEMENTS_CLASS=E,o.EVENTS=f,o.Helpers=d,o.TLH=T,o.TLHAnimation=O,o.TimeLine=P,o.default=T,Object.defineProperties(o,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})}));
//# sourceMappingURL=tlh-animations.umd.js.map
